<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I2E Invoice Validator</title>
    
    <!-- External Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
    
    <!-- I2E Modules -->
    <script src="shared/i2e-common.js"></script>
    <script src="shared/i2e-cache.js"></script>
    <script src="shared/i2e-spy.js"></script>
    <script src="shared/excel-exporter.js"></script>
    
    <!-- Shared Styles -->
    <link rel="stylesheet" href="assets/i2e-styles.css">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header" style="position: relative;">
            <button onclick="window.location.href = 'index.html'" title="Home" style="position: absolute; top: 10px; left: 20px; width: 40px; height: 40px; background: none; border: none; cursor: pointer; opacity: 1.0; transition: opacity 0.3s ease; font-size: 1.5rem;">üè†</button>
            <button onclick="exportCacheData()" title="Export all cached invoice data to Excel" style="position: absolute; bottom: 10px; right: 20px; padding: 0.5rem 1rem; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer; font-size: 0.9rem; transition: all 0.3s ease;">üì§ Export your data to Excel</button>
            <h1>I2E Invoice Validator</h1>
            <p>Compare invoiced amounts against internal employee costs and external supplier costs</p>
            
        </div>
        
        <!-- Tab Container -->
        <div class="card">
            <div class="tab-container">
                <div class="tab-nav">
                    <button class="tab-button active" onclick="switchTab('pending')">Pending Invoices</button>
                    <button class="tab-button" onclick="switchTab('overview')">Project Overview</button>
                    <button class="tab-button" id="detailsTabBtn" onclick="switchTab('details')" style="display: none;">Invoice Details</button>
                </div>
                
                
                <!-- Tab 3: Project Overview -->
                <div id="overviewTab" class="tab-content">
                    <!-- Validation Results -->
                    <div class="card" id="validationResults" style="display: none;">
                        <!-- Filter Controls - Top Row -->
                        <div class="filter-container" style="margin-bottom: 1rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div class="filter-input">
                                    <label style="font-weight: 600; margin-bottom: 0.5rem; display: block;">Project Name Filter:</label>
                                    <input type="text" id="projectFilter" placeholder="Type to filter projects..." onkeyup="updateProjectOverviewDropdown()" style="padding: 0.75rem; width: 100%; font-size: 1rem; border: 2px solid #e5e7eb; border-radius: 8px;">
                                    <small style="color: #6b7280;">Search by Project Name or WBS ID (case insensitive)</small>
                                    <!-- Left side button under text filter -->
                                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                        <button class="btn" onclick="clearProjectFilter()" style="padding: 0.5rem 1rem; font-size: 0.9rem;">Clear Filter</button>
                                    </div>
                                </div>
                                <div class="filter-dropdown">
                                    <label style="font-weight: 600; margin-bottom: 0.5rem; display: block;">Select Projects: <small style="color: #059669;">(Hold Ctrl/Cmd for multiple)</small></label>
                                    <select id="projectOverviewSelect" multiple size="4" style="padding: 0.5rem; width: 100%; font-size: 0.9rem; border: 2px solid #e5e7eb; border-radius: 8px;" onchange="applyProjectOverviewSelection()">
                                        <!-- Options will be populated dynamically -->
                                    </select>
                                    <!-- Right side buttons under dropdown -->
                                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                        <button class="btn" onclick="selectAllOverviewProjects()" style="padding: 0.5rem 1rem; font-size: 0.9rem;">Select All</button>
                                        <button class="btn" onclick="deselectAllOverviewProjects()" style="padding: 0.5rem 1rem; font-size: 0.9rem;">Deselect All</button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Filter Options Row -->
                            <div style="margin-bottom: 1rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem; justify-content: center;">
                                    <input type="checkbox" id="pendingInvoicesFilter" checked onchange="filterProjects()">
                                    <span>Show only projects with pending invoices</span>
                                    <small style="color: #6b7280; margin-left: 1rem;">Uncheck to see all validation results</small>
                                </label>
                            </div>
                            
                            <!-- Buttons Row -->
                            <div style="display: flex; justify-content: center; gap: 1rem; margin-bottom: 1rem;">
                                <button class="btn btn-primary" id="validateProjectBtn" onclick="validateSelectedProject()" disabled style="padding: 0.75rem 2rem;">üîç Validate Selected Project</button>
                            </div>
                            
                            
                            <div id="filterResults" class="filter-results" style="display: none;">
                                <!-- Filter summary will be shown here -->
                            </div>
                        </div>
                        
                        <!-- Main Validation Table -->
                        <div style="overflow-x: auto;">
                            <table class="data-table" id="validationTable" style="min-width: 1000px;">
                                <thead>
                                    <tr>
                                        <th style="width: 40px;">Select</th>
                                        <th onclick="sortTable(1)" style="cursor: pointer; min-width: 120px;">WBS Code</th>
                                        <th onclick="sortTable(2)" style="cursor: pointer; min-width: 200px;">Project Name</th>
                                        <th onclick="sortTable(3)" style="cursor: pointer; min-width: 120px;">Internal Cost</th>
                                        <th onclick="sortTable(4)" style="cursor: pointer; min-width: 120px;">External Cost</th>
                                        <th onclick="sortTable(5)" style="cursor: pointer; min-width: 120px;">Total Cost</th>
                                        <th onclick="sortTable(6)" style="cursor: pointer; min-width: 130px;">Invoiced Amount</th>
                                        <th onclick="sortTable(7)" style="cursor: pointer; min-width: 100px;">Delta</th>
                                    </tr>
                                </thead>
                                <tbody id="validationTableBody">
                                    <!-- Validation rows will be dynamically added here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <!-- Tab 2: Pending Invoices -->
                <div id="pendingTab" class="tab-content active">
                    <div class="card">
                        
                        <!-- Project Filter Bar (hidden by default) -->
                        <div id="projectFilterBar" class="info-bar" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #fff7ed; border-radius: 8px; border-left: 4px solid #f59e0b;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="font-size: 1.2rem;">üéØ</span>
                                    <div>
                                        <strong>Filtered by project:</strong> 
                                        <span id="filteredProjectName" style="font-family: monospace; color: #92400e;"></span>
                                    </div>
                                </div>
                                <button class="btn" onclick="clearPendingProjectFilter()">üóëÔ∏è Clear Filter</button>
                            </div>
                        </div>
                        
                        
                        <!-- Pending Invoices Table -->
                        <div style="overflow-x: auto;">
                            <table class="data-table" id="pendingInvoicesTable" style="min-width: 1000px;">
                                <thead>
                                    <tr>
                                        <th><input type="checkbox" id="selectAllPending" onchange="toggleSelectAllPending()"></th>
                                        <th onclick="sortPendingTable(1)" style="cursor: pointer;">Invoice #</th>
                                        <th onclick="sortPendingTable(2)" style="cursor: pointer;">Project</th>
                                        <th onclick="sortPendingTable(3)" style="cursor: pointer;">Amount</th>
                                        <th onclick="sortPendingTable(4)" style="cursor: pointer;">Internal Cost</th>
                                        <th onclick="sortPendingTable(5)" style="cursor: pointer;">External Cost</th>
                                        <th onclick="sortPendingTable(6)" style="cursor: pointer;">Total Cost</th>
                                        <th onclick="sortPendingTable(7)" style="cursor: pointer;">Delta</th>
                                        <th style="min-width: 140px;">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="pendingInvoicesTableBody">
                                    <!-- Pending invoice rows will be dynamically added here -->
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Bulk Actions -->
                        <div class="bulk-actions" style="margin-top: 1rem; padding: 1rem; background: #f8fafc; border-radius: 8px; display: none;" id="bulkActions">
                            <div style="display: flex; gap: 1rem; align-items: center;">
                                <span style="font-weight: 500;">Selected: <span id="selectedCount">0</span> invoices</span>
                                <button class="btn btn-success" onclick="bulkApproveInvoices()">‚úÖ Approve Selected</button>
                                <button class="btn btn-warning" onclick="bulkRejectInvoices()">‚ùå Reject Selected</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                
                <!-- Tab 5: Service Period Details -->
                <div id="detailsTab" class="tab-content">
                    <div class="card">
                        <p id="detailsPlaceholder">Detailed invoice and cost data will be shown here once an invoice is selected for detailed review in the 'Pending Invoices' tab.</p>
                        <div id="detailsContent">
                            <!-- Service period details will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script>
        // ===== GLOBAL DATA STORAGE =====
        let validationData = {
            ppmData: [],        // Changed to array for consolidation
            extSapData: [],     // Changed to array for consolidation
            i2eData: [],        // Changed to array for consolidation
            processedResults: null,
            currentWBS: null,
            currentMonth: null,
            cachedInvoices: null,
            selectedInvoices: [],
            sourceFiles: {      // Track source files for debugging
                ppm: [],
                extSap: [],
                i2e: []
            },
            consolidationStats: {  // Track consolidation statistics
                totalFiles: 0,
                ppmTabs: 0,
                extSapTabs: 0,
                i2eTabs: 0,
                duplicatesRemoved: {
                    ppm: 0,
                    extSap: 0,
                    i2e: 0
                }
            }
        };

        // ===== SESSION STORAGE PERSISTENCE =====
        function saveDataToSession() {
            try {
                const dataToSave = {
                    ppmData: validationData.ppmData,
                    extSapData: validationData.extSapData,
                    i2eData: validationData.i2eData,
                    sourceFiles: validationData.sourceFiles,
                    consolidationStats: validationData.consolidationStats,
                    savedAt: new Date().toISOString()
                };
                
                sessionStorage.setItem('i2e-validation-data', JSON.stringify(dataToSave));
                console.log('‚úÖ Data saved to session storage');
                
                return true;
            } catch (error) {
                console.error('‚ùå Failed to save data to session storage:', error);
                return false;
            }
        }

        async function loadDataFromSession() {
            try {
                // First, try to load from session storage (uploaded data)
                const savedData = sessionStorage.getItem('i2e-validation-data');
                let hasSessionData = false;
                
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    
                    validationData.ppmData = parsedData.ppmData || [];
                    validationData.extSapData = parsedData.extSapData || [];
                    validationData.i2eData = parsedData.i2eData || [];
                    validationData.sourceFiles = parsedData.sourceFiles || { ppm: [], extSap: [], i2e: [] };
                    validationData.consolidationStats = parsedData.consolidationStats || {
                        totalFiles: 0, ppmTabs: 0, extSapTabs: 0, i2eTabs: 0,
                        duplicatesRemoved: { ppm: 0, extSap: 0, i2e: 0 }
                    };
                    
                    console.log('‚úÖ Data loaded from session storage:', {
                        ppmRecords: validationData.ppmData.length,
                        extSapRecords: validationData.extSapData.length,
                        i2eRecords: validationData.i2eData.length,
                        savedAt: parsedData.savedAt
                    });
                    
                    hasSessionData = true;
                }
                
                // CRITICAL FIX: If no session data, try to load from IndexedDB (data uploaded on index page)
                if (!hasSessionData) {
                    const costData = await loadFromIndexedDB('i2e_cost_data_cache', []);
                    
                    console.log('üîç Raw cost data from IndexedDB:', costData);
                    console.log('üîç Cost data length:', costData.length);
                    
                    // Debug the actual data structure
                    if (costData.length > 0) {
                        console.log('üîç Sample cost data items by source:');
                        ['PPM', 'EXT SAP', 'I2E'].forEach(source => {
                            const items = costData.filter(item => item.source === source);
                            console.log(`üîç ${source}:`, items.length, 'items');
                            if (items.length > 0) {
                                console.log(`üîç ${source} sample:`, items[0]);
                                console.log(`üîç ${source} keys:`, Object.keys(items[0]));
                            }
                        });
                    }
                    
                    if (costData.length > 0) {
                        // Convert localStorage cost data to validationData format
                        const ppmData = costData.filter(item => item.source === 'PPM');
                        const extSapData = costData.filter(item => item.source === 'EXT SAP');
                        const i2eData = costData.filter(item => item.source === 'I2E');
                        
                        console.log('üîç Filtered cost data:', {
                            ppmData: ppmData.length,
                            extSapData: extSapData.length,
                            i2eData: i2eData.length,
                            samplePPM: ppmData.length > 0 ? ppmData[0] : null,
                            sampleExtSap: extSapData.length > 0 ? extSapData[0] : null
                        });
                        
                        // Handle both old simplified format and new Excel format
                        const convertedPpmData = ppmData.map(item => {
                            // Check if it's old simplified format or new Excel format
                            if (item.wbs) {
                                // Old simplified format - convert to Excel format
                                return {
                                    'WBS Element ID': item.wbs,
                                    'Project Name': item.projectName || 'Unknown Project', 
                                    'Cost ‚Ç¨': item.value,
                                    'Month of invoice': item.month,
                                    'User': item.user || 'Unknown',
                                    'Role 2025': item.role || 'Unknown',
                                    'Rate 2025': item.rate || 0,
                                    source: 'PPM'
                                };
                            } else {
                                // New Excel format - use as is
                                return {
                                    ...item,
                                    source: 'PPM'
                                };
                            }
                        });
                        
                        const convertedExtSapData = extSapData.map(item => {
                            // Check if it's old simplified format or new Excel format
                            if (item.wbs) {
                                // Old simplified format - convert to Excel format
                                return {
                                    'WBS Element': item.wbs,
                                    'WBS Element ID': item.wbs,
                                    'WBS': item.wbs,
                                    'CO object name': item.projectName || 'Unknown Project',
                                    'Value': item.value,
                                    'Period': item.period || 1,
                                    'Fiscal Year': item.fiscalYear || new Date().getFullYear(),
                                    'Cost Element': item.costElement || 'Unknown',
                                    'Cost element name': item.costElementName || 'Unknown',
                                    source: 'EXT SAP'
                                };
                            } else {
                                // New Excel format - use as is
                                return {
                                    ...item,
                                    source: 'EXT SAP'
                                };
                            }
                        });
                        
                        validationData.ppmData = convertedPpmData;
                        validationData.extSapData = convertedExtSapData;
                        validationData.i2eData = i2eData;
                        validationData.sourceFiles = { ppm: [], extSap: [], i2e: [] };
                        validationData.consolidationStats = {
                            totalFiles: 0, ppmTabs: 0, extSapTabs: 0, i2eTabs: 0,
                            duplicatesRemoved: { ppm: 0, extSap: 0, i2e: 0 }
                        };
                        
                        console.log('‚úÖ Data loaded from localStorage (index page):', {
                            ppmRecords: ppmData.length,
                            extSapRecords: extSapData.length,
                            i2eRecords: i2eData.length,
                            totalCostData: costData.length
                        });
                        
                        hasSessionData = true;
                    } else {
                        console.log('‚ùå No cost data found in localStorage');
                    }
                }
                
                return hasSessionData;
            } catch (error) {
                console.error('‚ùå Failed to load data from storage:', error);
                return false;
            }
        }

        function clearSessionData() {
            try {
                sessionStorage.removeItem('i2e-validation-data');
                console.log('‚úÖ Session data cleared');
            } catch (error) {
                console.error('‚ùå Failed to clear session data:', error);
            }
        }

        async function updateDataSourceStatus() {
            // File info displays removed - data now uploaded in index screen
            
            // Check if we're ready to process after updating the UI
            await checkReadyToProcess();
        }


        // ===== DEBUG FUNCTIONS =====
        
        async function debugValidatorCacheData() {
            console.log('üîç Debug Validator Cache Data:');
            console.log('Raw localStorage data:');
            console.log('  - i2e_pending_invoices:', localStorage.getItem('i2e_pending_invoices'));
            console.log('  - i2e_approved_invoices:', localStorage.getItem('i2e_approved_invoices'));
            console.log('  - i2e_rejected_invoices:', localStorage.getItem('i2e_rejected_invoices'));
            console.log('  - i2e_cost_data_cache:', localStorage.getItem('i2e_cost_data_cache'));
            
            console.log('Parsed cache data:');
            const pendingInvoices = await getPendingInvoices();
            const approvedInvoices = await getApprovedInvoices();
            const rejectedInvoices = await getRejectedInvoices();
            const costDataCache = await loadFromIndexedDB('i2e_cost_data_cache', []);
            
            console.log('  - Pending invoices:', pendingInvoices);
            console.log('  - Approved invoices:', approvedInvoices);
            console.log('  - Rejected invoices:', rejectedInvoices);
            console.log('  - Cost data cache:', costDataCache);
            
            console.log('Cache stats:');
            try {
                const cacheStats = await getCacheStats();
                console.log('  - Cache stats:', cacheStats);
            } catch (error) {
                console.log('  - Cache stats error:', error);
            }
            
            console.log('Validation data:', validationData);
            console.log('Cost data available:', isCostDataAvailable());
        }
        
        // Make debug function globally available
        window.debugValidatorCacheData = debugValidatorCacheData;

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', async function() {
            // Check URL parameters for navigation from main dashboard
            const urlParams = new URLSearchParams(window.location.search);
            const requestedView = urlParams.get('view');
            
            // Try to load data from session storage first
            const hasSessionData = await loadDataFromSession();
            
            await initializeValidator();
            
            if (hasSessionData) {
                // Update UI to show loaded data
                await updateDataSourceStatus();
                
                // Reload pending invoices if we have cost data
                const pendingInvoices = await getPendingInvoices();
                if (pendingInvoices && pendingInvoices.length > 0) {
                    displayPendingInvoices(pendingInvoices);
                    console.log(`üîÑ Restored ${pendingInvoices.length} pending invoices from cache`);
                }
                
                // Re-evaluate tab landing logic after loading session data
                const hasExistingCostData = isCostDataAvailable();
                console.log('üîç Re-evaluating tab landing after session data load:', hasExistingCostData);
                if (hasExistingCostData) {
                    switchTab('pending');
                } else {
                    switchTab('pending');
                }
                
                // Update tab button states again
                updateTabButtonStates();
            }
            
            // Handle navigation from main dashboard
            if (requestedView) {
                handleDashboardNavigation(requestedView);
            }
                
            console.log('üîÑ Session data restored, updating UI...');
            
            // Ensure pending invoices filter is applied after initialization
            setTimeout(() => {
                if (document.getElementById('validationResults').style.display !== 'none') {
                    console.log('üîç Applying initial pending invoices filter...');
                    filterProjects();
                }
            }, 500);
        });

        async function initializeValidator() {
            console.log('üîç Initializing I2E Invoice Validator...');
            
            // Inject spy icon into header
            injectSpyIcon();
            
            // Load cached invoices immediately
            await loadCachedInvoices();
            
            // File upload handlers removed - data now uploaded in index screen
            
            // Smart landing tab: Pending Invoices
            const hasExistingCostData = isCostDataAvailable();
            if (hasExistingCostData) {
                switchTab('pending');
            } else {
                switchTab('pending');
            }
            
            // Update tab button states based on available data
            updateTabButtonStates();
            
            console.log('‚úÖ I2E Invoice Validator initialized');
        }

        // ===== CACHE MANAGEMENT =====
        async function loadCachedInvoices() {
            try {
                console.log('üìã Loading cached invoices...');
                
                const pendingInvoices = await getPendingInvoices();
                const cacheStats = await getCacheStats();
                
                console.log('üîç Raw pendingInvoices from getPendingInvoices():', pendingInvoices);
                console.log('üîç Cache stats:', cacheStats);
                
                validationData.cachedInvoices = pendingInvoices;
                
                console.log(`üìä Cache loaded: ${cacheStats.counts.pending} pending, ${cacheStats.counts.approved} approved, ${cacheStats.counts.rejected} rejected`);
                
                // Update pending invoices display
                console.log('üìã Calling displayPendingInvoices with', pendingInvoices.length, 'invoices');
                displayPendingInvoices(pendingInvoices);
                
                // Update info bar
                updatePendingInfoBar(cacheStats);
                
                // Update cache info on landing tab
                updateCacheInfoPanel(cacheStats);
                
                // Apply project filter if active on pending tab
                if (currentProjectFilter) {
                    setTimeout(() => {
                        applyProjectFilterToPendingInvoices();
                    }, 100);
                }
                
                console.log('‚úÖ loadCachedInvoices completed successfully');
                
            } catch (error) {
                console.error('‚ùå Error loading cached invoices:', error);
                displayPendingInvoices([]);
            }
        }

        function displayPendingInvoices(pendingInvoices) {
            const tableBody = document.getElementById('pendingInvoicesTableBody');
            
            console.log('üîç displayPendingInvoices called with:', pendingInvoices);
            console.log('üîç pendingInvoices length:', pendingInvoices ? pendingInvoices.length : 'null/undefined');
            
            if (!pendingInvoices || pendingInvoices.length === 0) {
                console.log('‚ùå No pending invoices to display');
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="11" style="text-align: center; padding: 2rem; color: #6b7280;">
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">üì≠</div>
                            <div>No pending invoices found</div>
                            <div style="font-size: 0.9rem; margin-top: 0.5rem;">
                                Process some invoices in the I2E Invoice Processor first
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }
            
            console.log(`üìã Displaying ${pendingInvoices.length} pending invoices`);
            
            tableBody.innerHTML = pendingInvoices.map((invoice, index) => {
                const invoiceNumber = getInvoiceNumber(invoice);
                const projectId = getProjectId(invoice);
                const invoiceTotal = getInvoiceTotal(invoice);
                const invoiceDate = getInvoiceDate(invoice);
                const monthOfInvoice = getMonthOfInvoice(invoice);
                const sourceText = invoice.source === 'new' ? 'New' : 'Cache';
                
                // Check if this is a corrected credit note
                const isCorrectCreditNote = invoice.fullInvoiceData && invoice.fullInvoiceData.length > 0 && 
                                          invoice.fullInvoiceData[0].creditNote && 
                                          invoice.fullInvoiceData[0].isCreditNoteCorrected;
                
                // Calculate costs for this invoice based on month filtering
                const costs = calculateInvoiceCosts(invoice, monthOfInvoice);
                
                // Calculate delta (difference between invoice amount and total costs)
                const delta = invoiceTotal - costs.totalCost;
                const isDeltaZero = Math.abs(delta) < 0.01; // Consider amounts within 1 cent as zero
                
                // Determine row styling (green for zero delta overrides credit note blue)
                const rowStyle = isDeltaZero ? 
                    'style="background: #f0fdf4; border-left: 4px solid #10b981;"' : 
                    (isCorrectCreditNote ? 'style="background: #f0f9ff; border-left: 4px solid #0ea5e9;"' : '');
                
                return `
                    <tr data-invoice="${invoiceNumber}" ${rowStyle}>
                        <td>
                            <input type="checkbox" class="invoice-checkbox" value="${invoiceNumber}" onchange="updateSelectedInvoices()">
                        </td>
                        <td><strong>${invoiceNumber}</strong>${isCorrectCreditNote && !isDeltaZero ? ' <span style="color: #0ea5e9; font-size: 0.8rem;">üìù Credit Note</span>' : ''}${isDeltaZero ? ' <span style="color: #10b981; font-size: 0.8rem;">‚úì Match</span>' : ''}</td>
                        <td>${projectId}</td>
                        <td>${formatCurrency(invoiceTotal)}</td>
                        <td>${formatCurrency(costs.internalCost)}</td>
                        <td>${formatCurrency(costs.externalCost)}</td>
                        <td><strong>${formatCurrency(costs.totalCost)}</strong></td>
                        <td style="color: ${Math.abs(delta) < 0.01 ? '#059669' : (delta < 0 ? '#dc2626' : 'inherit')}; font-weight: bold;">${formatCurrency(delta)}</td>
                        <td>
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="btn btn-success" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="handleApproveInvoice('${invoiceNumber}')">Approve</button>
                                <button class="btn btn-warning" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="handleRejectInvoice('${invoiceNumber}')">Reject</button>
                                <button class="btn" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" onclick="showInvoiceDetails('${invoiceNumber}')">Details</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function updatePendingInfoBar(cacheStats) {
            const infoBar = document.getElementById('pendingInfoBar');
            const infoText = document.getElementById('pendingInfoText');
            
            if (!infoBar || !infoText) {
                console.log('‚ö†Ô∏è Info bar elements not found, skipping update');
                return;
            }
            
            if (cacheStats.counts.total === 0) {
                infoBar.style.display = 'none';
                return;
            }
            
            infoBar.style.display = 'block';
            
            const parts = [];
            if (cacheStats.counts.pending > 0) parts.push(`${cacheStats.counts.pending} pending`);
            if (cacheStats.counts.approved > 0) parts.push(`${cacheStats.counts.approved} approved`);
            if (cacheStats.counts.rejected > 0) parts.push(`${cacheStats.counts.rejected} rejected`);
            
            infoText.innerHTML = `
                You have ${parts.join(', ')} invoices in cache. 
                ${cacheStats.counts.pending > 0 ? '<strong>Only pending invoices remain in cache after approval/rejection.</strong>' : ''}
            `;
        }

        // ===== DASHBOARD NAVIGATION =====
        function handleDashboardNavigation(requestedView) {
            console.log('üéØ Navigation requested from dashboard:', requestedView);
            
            // Modify the interface based on the requested view
            if (requestedView === 'pending') {
                // Hide specific tabs when coming from invoice approval
                // (costdata tab removed)
                
                // Update header
                document.querySelector('.header h1').textContent = '‚úÖ Invoice Extraction & Approval';
                document.querySelector('.header p').textContent = 'Review and approve pending invoices against cost data';
                
                // Switch to pending invoices tab
                switchTab('pending');
                
            } else if (requestedView === 'validation') {
                // Hide specific tabs for invoice validation
                // (costdata tab removed)
                
                // Update header
                document.querySelector('.header h1').textContent = 'Invoice Validation';
                document.querySelector('.header p').textContent = 'Validate invoices against cost data';
                
                // Switch to pending invoices tab
                switchTab('pending');
                
            } else if (requestedView === 'costviews') {
                // Cost views moved to separate page - redirect
                console.log('üîç Navigation: Redirecting to cost views page');
                window.location.href = 'I2E_Cost_view.html';
            }
            
            // Add back to dashboard button
            addBackToDashboardButton();
        }
        
        function hideTabs(tabsToHide) {
            tabsToHide.forEach(tabName => {
                const button = document.querySelector(`button[onclick="switchTab('${tabName}')"]`);
                if (button) {
                    button.style.display = 'none';
                }
            });
        }
        
        function hideTabNavigation() {
            const tabNav = document.querySelector('.tab-nav');
            if (tabNav) {
                tabNav.style.display = 'none';
            }
        }
        
        // showCostViewsOnly function removed - Cost Views moved to separate page
        
        function addBackToDashboardButton() {
            // Back to dashboard button removed - users can use home button instead
        }

        // ===== TAB NAVIGATION =====
        function switchTab(tabName) {
            // Check if cost data is required and not available
            if ((tabName === 'pending' || tabName === 'overview') && !isCostDataAvailable()) {
                alert('‚ö†Ô∏è Cost data required!\n\nPlease upload PPM and EXT SAP data in the main dashboard before accessing pending invoices or project overview.');
                // Stay on current tab if no cost data available
                return;
            }
            
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Find and activate the correct button
            const targetButton = Array.from(document.querySelectorAll('.tab-button')).find(btn => 
                btn.onclick.toString().includes(`switchTab('${tabName}')`)
            );
            if (targetButton) {
                targetButton.classList.add('active');
            }
            
            // Update tab button states
            updateTabButtonStates();
            
            // Apply filters when switching to overview tab
            if (tabName === 'overview') {
                // Small delay to ensure DOM is updated
                setTimeout(() => {
                    // Show validation results if we have processed data
                    if (validationData.processedResults) {
                        document.getElementById('validationResults').style.display = 'block';
                        displayValidationResults(validationData.processedResults);
                        updateProjectOverviewDropdown();
                        filterProjects();
                    } else if (isCostDataAvailable()) {
                        // Process validation if we have data but no results yet
                        const results = processValidationLogic();
                        validationData.processedResults = results;
                        document.getElementById('validationResults').style.display = 'block';
                        displayValidationResults(results);
                        updateProjectOverviewDropdown();
                        filterProjects();
                    }
                }, 50);
            }
            
            // Cost views tab removed - functionality moved to separate page
        }
        
        // Check if cost data is available
        function isCostDataAvailable() {
            const hasPPM = Array.isArray(validationData.ppmData) && validationData.ppmData.length > 0;
            const hasExtSap = Array.isArray(validationData.extSapData) && validationData.extSapData.length > 0;
            
            console.log('üîç isCostDataAvailable check:', {
                hasPPM,
                hasExtSap,
                ppmCount: validationData.ppmData ? validationData.ppmData.length : 0,
                extSapCount: validationData.extSapData ? validationData.extSapData.length : 0,
                rawCostDataCache: 'IndexedDB (async)'
            });
            
            return validationData && hasPPM && hasExtSap;
        }
        
        // Update tab button visual states based on data availability
        function updateTabButtonStates() {
            const hasCostData = isCostDataAvailable();
            const pendingBtn = document.querySelector('button[onclick*="pending"]');
            const overviewBtn = document.querySelector('button[onclick*="overview"]');
            
            if (pendingBtn) {
                if (hasCostData) {
                    pendingBtn.style.opacity = '1';
                    pendingBtn.style.cursor = 'pointer';
                    pendingBtn.disabled = false;
                } else {
                    pendingBtn.style.opacity = '0.5';
                    pendingBtn.style.cursor = 'not-allowed';
                    pendingBtn.disabled = true;
                }
            }
            
            if (overviewBtn) {
                if (hasCostData) {
                    overviewBtn.style.opacity = '1';
                    overviewBtn.style.cursor = 'pointer';
                    overviewBtn.disabled = false;
                } else {
                    overviewBtn.style.opacity = '0.5';
                    overviewBtn.style.cursor = 'not-allowed';
                    overviewBtn.disabled = true;
                }
            }
        }

        // ===== DATA CONSOLIDATION AND DEDUPLICATION =====
        
        /**
         * Extract year from PPM "Week starts on" column
         * @param {string} weekStartsOn - Date string from "Week starts on" column
         * @returns {number} Year or null if cannot parse
         */
        function extractYearFromWeekStartsOn(weekStartsOn) {
            if (!weekStartsOn) return null;
            
            try {
                // Handle various date formats
                const date = new Date(weekStartsOn);
                if (isNaN(date.getTime())) {
                    console.warn(`Could not parse week starts on date: ${weekStartsOn}`);
                    return null;
                }
                return date.getFullYear();
            } catch (error) {
                console.warn(`Error parsing week starts on date: ${weekStartsOn}`, error);
                return null;
            }
        }
        
        /**
         * Deduplicate PPM data based on unique identifiers
         * @param {Array} ppmArray - Array of PPM records
         * @returns {Object} {deduplicated: Array, duplicatesRemoved: number}
         */
        function deduplicatePPMData(ppmArray) {
            const uniqueKeys = new Set();
            const deduplicated = [];
            let duplicatesRemoved = 0;
            
            ppmArray.forEach(row => {
                // Create unique key: WBS + User + Month + Year + Week (support RTC Project field)
                const wbs = row['WBS Element'] || row['WBS Element ID'] || row['WBS'] || row['Project'] || row.project || '';
                const user = row['User'] || row['Employee'] || '';
                const month = row['Month of invoice'] || '';
                const year = extractYearFromWeekStartsOn(row['Week starts on']) || '';
                const week = row['Week starts on'] || '';
                
                const uniqueKey = `${wbs}|${user}|${month}|${year}|${week}`;
                
                if (!uniqueKeys.has(uniqueKey)) {
                    uniqueKeys.add(uniqueKey);
                    // Add year to the record for filtering
                    row._extractedYear = year;
                    deduplicated.push(row);
                } else {
                    duplicatesRemoved++;
                    console.log(`Duplicate PPM record removed: ${uniqueKey}`);
                }
            });
            
            return { deduplicated, duplicatesRemoved };
        }
        
        /**
         * Deduplicate EXT SAP data based on unique identifiers
         * @param {Array} extSapArray - Array of EXT SAP records
         * @returns {Object} {deduplicated: Array, duplicatesRemoved: number}
         */
        function deduplicateExtSapData(extSapArray) {
            const uniqueKeys = new Set();
            const deduplicated = [];
            let duplicatesRemoved = 0;
            
            extSapArray.forEach(row => {
                // Create unique key: WBS + Document + Period + FiscalYear + Value
                const wbs = row['WBS Element'] || row['WBS'] || '';
                const document = row['Document'] || row['Doc'] || '';
                const period = row['Period'] || '';
                const fiscalYear = row['Fiscal Year'] || row['FiscalYear'] || '';
                const value = row['Value'] || row['Amount'] || '';
                
                const uniqueKey = `${wbs}|${document}|${period}|${fiscalYear}|${value}`;
                
                if (!uniqueKeys.has(uniqueKey)) {
                    uniqueKeys.add(uniqueKey);
                    deduplicated.push(row);
                } else {
                    duplicatesRemoved++;
                    console.log(`Duplicate EXT SAP record removed: ${uniqueKey}`);
                }
            });
            
            return { deduplicated, duplicatesRemoved };
        }
        
        /**
         * Deduplicate I2E invoice data based on unique identifiers
         * @param {Array} i2eArray - Array of I2E invoice records
         * @returns {Object} {deduplicated: Array, duplicatesRemoved: number}
         */
        function deduplicateI2EData(i2eArray) {
            const uniqueKeys = new Set();
            const deduplicated = [];
            let duplicatesRemoved = 0;
            
            i2eArray.forEach(row => {
                // Create unique key: Invoice + Position + Project + Amount
                const invoice = row['invoiceNumber'] || row['Invoice Number'] || '';
                const position = row['position'] || row['Position'] || '';
                const project = row['projectId'] || row['Project ID'] || '';
                const amount = row['positionTotal'] || row['Amount'] || '';
                
                const uniqueKey = `${invoice}|${position}|${project}|${amount}`;
                
                if (!uniqueKeys.has(uniqueKey)) {
                    uniqueKeys.add(uniqueKey);
                    deduplicated.push(row);
                } else {
                    duplicatesRemoved++;
                    console.log(`Duplicate I2E record removed: ${uniqueKey}`);
                }
            });
            
            return { deduplicated, duplicatesRemoved };
        }
        
        /**
         * Consolidate and deduplicate all loaded data
         */
        function consolidateAndDeduplicateData() {
            console.log('üîÑ Starting data consolidation and deduplication...');
            
            // Deduplicate PPM data
            if (validationData.ppmData.length > 0) {
                const ppmResult = deduplicatePPMData(validationData.ppmData);
                validationData.ppmData = ppmResult.deduplicated;
                validationData.consolidationStats.duplicatesRemoved.ppm = ppmResult.duplicatesRemoved;
                console.log(`‚úÖ PPM: ${ppmResult.deduplicated.length} unique records, ${ppmResult.duplicatesRemoved} duplicates removed`);
            }
            
            // Deduplicate EXT SAP data
            if (validationData.extSapData.length > 0) {
                const extSapResult = deduplicateExtSapData(validationData.extSapData);
                validationData.extSapData = extSapResult.deduplicated;
                validationData.consolidationStats.duplicatesRemoved.extSap = extSapResult.duplicatesRemoved;
                console.log(`‚úÖ EXT SAP: ${extSapResult.deduplicated.length} unique records, ${extSapResult.duplicatesRemoved} duplicates removed`);
            }
            
            // Deduplicate I2E data
            if (validationData.i2eData.length > 0) {
                const i2eResult = deduplicateI2EData(validationData.i2eData);
                validationData.i2eData = i2eResult.deduplicated;
                validationData.consolidationStats.duplicatesRemoved.i2e = i2eResult.duplicatesRemoved;
                console.log(`‚úÖ I2E: ${i2eResult.deduplicated.length} unique records, ${i2eResult.duplicatesRemoved} duplicates removed`);
            }
            
            console.log('üéØ Data consolidation completed:', validationData.consolidationStats);
        }

        // ===== MULTIPLE INVOICE DETECTION =====
        
        /**
         * Check for multiple pending invoices for same project and month
         * @param {string} currentInvoiceNumber - Current invoice number
         * @param {string} projectId - Project ID
         * @param {string} monthOfInvoice - Month of invoice
         * @returns {Array} Array of other invoice numbers for same project/month
         */
        async function checkForMultipleInvoicesInMonth(currentInvoiceNumber, projectId, monthOfInvoice) {
            const pendingInvoices = await getPendingInvoices();
            const sameProjectMonth = [];
            
            pendingInvoices.forEach(invoice => {
                if (invoice.invoiceNumber === currentInvoiceNumber) return; // Skip current invoice
                
                const invProjectId = getProjectId(invoice);
                const invMonth = getMonthOfInvoice(invoice);
                
                if (invProjectId === projectId && invMonth === monthOfInvoice) {
                    sameProjectMonth.push(invoice.invoiceNumber);
                }
            });
            
            return sameProjectMonth;
        }
        
        /**
         * Show notification for multiple invoices in same project/month
         * @param {string} invoiceNumber - Current invoice
         * @param {Array} otherInvoices - Other invoice numbers
         * @param {string} projectId - Project ID
         * @param {string} monthOfInvoice - Month
         */
        function showMultipleInvoiceNotification(invoiceNumber, otherInvoices, projectId, monthOfInvoice) {
            if (otherInvoices.length === 0) return;
            
            const message = `‚ö†Ô∏è Multiple pending invoices detected!\n\nProject: ${projectId}\nMonth: ${monthOfInvoice}\n\nOther pending invoices:\n${otherInvoices.join(', ')}\n\nTotal cost shown may exceed individual invoice amounts.`;
            
            // Show as notification instead of alert to be less intrusive
            showNotification(message, 'warning', 8000); // Show for 8 seconds
        }

        // ===== APPROVAL WORKFLOW =====
        async function handleApproveInvoice(invoiceNumber) {
            const comments = prompt(`Approve invoice ${invoiceNumber}?\n\nOptional comments:`);
            
            if (comments !== null) { // User didn't cancel
                try {
                    const userId = getUserId();
                    console.log(`üîÑ Attempting to approve invoice ${invoiceNumber} by ${userId} with comments: "${comments}"`);
                    
                    if (typeof window.approveInvoice !== 'function') {
                        throw new Error('approveInvoice function not available - cache module may not be loaded');
                    }
                    
                    const result = await await window.approveInvoice(invoiceNumber, userId, comments);
                    console.log(`üîÑ Approval result: ${result}`);
                    
                    if (result === true) {
                        console.log(`‚úÖ Invoice approved: ${invoiceNumber}`);
                        
                        // Refresh display
                        await loadCachedInvoices();
                        
                        // Show success message
                        showNotification(`Invoice ${invoiceNumber} approved successfully`, 'success');
                        
                        // Check if we should show export reminder
                        setTimeout(checkAndShowExportReminder, 500);
                    } else {
                        throw new Error(`Approval function returned: ${result} (expected true). Check cache module and invoice data.`);
                    }
                } catch (error) {
                    console.error('Error approving invoice:', error);
                    alert(`Error approving invoice: ${error.message}\n\nPlease check the console for details and try again.`);
                }
            }
        }

        async function handleRejectInvoice(invoiceNumber) {
            const comments = prompt(`Reject invoice ${invoiceNumber}?\n\nReason for rejection (required):`);
            
            if (comments !== null && comments.trim() !== '') {
                try {
                    const userId = getUserId();
                    console.log(`üîÑ Attempting to reject invoice ${invoiceNumber} by ${userId} with reason: "${comments}"`);
                    
                    if (typeof window.rejectInvoice !== 'function') {
                        throw new Error('rejectInvoice function not available - cache module may not be loaded');
                    }
                    
                    const result = await window.rejectInvoice(invoiceNumber, userId, comments);
                    console.log(`üîÑ Rejection result: ${result}`);
                    
                    if (result === true) {
                        console.log(`‚ùå Invoice rejected: ${invoiceNumber}`);
                        
                        // Refresh display
                        await loadCachedInvoices();
                        
                        // Show success message
                        showNotification(`Invoice ${invoiceNumber} rejected`, 'warning');
                        
                        // Check if we should show export reminder
                        setTimeout(checkAndShowExportReminder, 500);
                    } else {
                        throw new Error(`Rejection function returned: ${result} (expected true). Check cache module and invoice data.`);
                    }
                } catch (error) {
                    console.error('Error rejecting invoice:', error);
                    alert(`Error rejecting invoice: ${error.message}\n\nPlease check the console for details and try again.`);
                }
            } else if (comments !== null) {
                alert('Rejection reason is required.');
            }
        }

        async function showInvoiceDetails(invoiceNumber) {
            // Store selected invoice for details tab
            validationData.selectedInvoiceNumber = invoiceNumber;
            
            // Enable and switch to details tab
            const detailsTabBtn = document.getElementById('detailsTabBtn');
            detailsTabBtn.style.display = 'inline-block';
            
            switchTab('details');
            
            // Load invoice details
            await loadInvoiceDetails(invoiceNumber);
        }

        // ===== BULK OPERATIONS =====
        function updateSelectedInvoices() {
            const checkboxes = document.querySelectorAll('.invoice-checkbox:checked');
            const selectedCount = checkboxes.length;
            const bulkActions = document.getElementById('bulkActions');
            const selectedCountSpan = document.getElementById('selectedCount');
            
            validationData.selectedInvoices = Array.from(checkboxes).map(cb => cb.value);
            selectedCountSpan.textContent = selectedCount;
            
            if (selectedCount > 0) {
                bulkActions.style.display = 'block';
            } else {
                bulkActions.style.display = 'none';
            }
        }

        function toggleSelectAllPending() {
            const selectAllCheckbox = document.getElementById('selectAllPending');
            const invoiceCheckboxes = document.querySelectorAll('.invoice-checkbox');
            
            invoiceCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateSelectedInvoices();
        }

        async function bulkApproveInvoices() {
            if (validationData.selectedInvoices.length === 0) {
                alert('No invoices selected.');
                return;
            }
            
            const comments = prompt(`Approve ${validationData.selectedInvoices.length} selected invoices?\n\nOptional comments:`);
            
            if (comments !== null) {
                const userId = getUserId();
                let successCount = 0;
                
                for (const invoiceNumber of validationData.selectedInvoices) {
                    if (await window.approveInvoice(invoiceNumber, userId, comments)) {
                        successCount++;
                    }
                }
                
                console.log(`‚úÖ Bulk approved: ${successCount}/${validationData.selectedInvoices.length} invoices`);
                
                // Refresh display
                await loadCachedInvoices();
                
                // Clear selections
                validationData.selectedInvoices = [];
                
                showNotification(`${successCount} invoices approved successfully`, 'success');
                
                // Check if we should show export reminder
                setTimeout(checkAndShowExportReminder, 500);
            }
        }

        async function bulkRejectInvoices() {
            if (validationData.selectedInvoices.length === 0) {
                alert('No invoices selected.');
                return;
            }
            
            const comments = prompt(`Reject ${validationData.selectedInvoices.length} selected invoices?\n\nReason for rejection (required):`);
            
            if (comments !== null && comments.trim() !== '') {
                const userId = getUserId();
                let successCount = 0;
                
                for (let index = 0; index < validationData.selectedInvoices.length; index++) {
                    const invoiceNumber = validationData.selectedInvoices[index];
                    console.log(`‚ùå Rejecting invoice ${index + 1}/${validationData.selectedInvoices.length}: ${invoiceNumber}`);
                    if (await window.rejectInvoice(invoiceNumber, userId, comments)) {
                        successCount++;
                        console.log(`‚úÖ Successfully rejected: ${invoiceNumber}`);
                    } else {
                        console.error(`‚ùå Failed to reject: ${invoiceNumber}`);
                    }
                }
                
                console.log(`‚ùå Bulk rejected: ${successCount}/${validationData.selectedInvoices.length} invoices`);
                
                // Refresh display
                await loadCachedInvoices();
                
                // Clear selections
                validationData.selectedInvoices = [];
                
                showNotification(`${successCount} invoices rejected`, 'warning');
                
                // Check if we should show export reminder
                setTimeout(checkAndShowExportReminder, 500);
            } else if (comments !== null) {
                alert('Rejection reason is required.');
            }
        }


        // Update cache info panel on landing tab
        function updateCacheInfoPanel(cacheStats) {
            const cacheInfoText = document.getElementById('cacheInfoText');
            if (cacheInfoText && cacheStats) {
                const totalInvoices = cacheStats.counts.total;
                const pendingCount = cacheStats.counts.pending;
                const approvedCount = cacheStats.counts.approved;
                const rejectedCount = cacheStats.counts.rejected;
                
                if (totalInvoices > 0) {
                    cacheInfoText.innerHTML = `
                        <strong>${totalInvoices} invoices in cache:</strong> 
                        ${pendingCount} pending, ${approvedCount} approved, ${rejectedCount} rejected
                        <br><small>Cache size: ${cacheStats.sizes.totalMB} MB (${cacheStats.limits.percentUsed}% of limit)</small>
                    `;
                } else {
                    cacheInfoText.innerHTML = 'No cached invoices found. Process invoices first using the I2E Invoice Processor.';
                }
            }
        }

        // ===== HELPER FUNCTIONS =====
        function getInvoiceDate(invoice) {
            if (invoice.summary && invoice.summary.invoiceDate) {
                return invoice.summary.invoiceDate;
            }
            if (invoice.fullInvoiceData && invoice.fullInvoiceData[0]) {
                return invoice.fullInvoiceData[0].dateOfInvoice;
            }
            return '';
        }

        function getUserId() {
            // Try to get user ID from preferences or browser
            try {
                const preferences = JSON.parse(localStorage.getItem('i2e_user_preferences') || '{}');
                if (preferences.windowsUserId) {
                    return preferences.windowsUserId;
                }
                
                // Fallback to browser info
                return navigator.userAgent.includes('Windows') ? 'windows-user' : 'unknown-user';
            } catch (error) {
                return 'unknown-user';
            }
        }

        function showNotification(message, type = 'info') {
            // Simple notification implementation
            console.log(`üì¢ ${type.toUpperCase()}: ${message}`);
            
            // You could enhance this with a proper notification system
            // For now, just log to console
        }




        async function checkReadyToProcess() {
            const hasData = validationData.ppmData || validationData.extSapData || validationData.i2eData;
            const processBtn = document.getElementById('processBtn');
            
            // If button doesn't exist, just return (element may have been removed)
            if (!processBtn) return;
            
            // Enable button if we have uploaded data OR cached invoices
            const cacheStats = await getCacheStats();
            const hasCachedInvoices = cacheStats.counts.pending > 0 || cacheStats.counts.approved > 0;
            
            processBtn.disabled = !(hasData || hasCachedInvoices);
            
            // Update button text based on current state
            if (hasCachedInvoices && !hasData) {
                processBtn.textContent = 'üìã View Pending Invoices';
            } else {
                processBtn.textContent = '‚úÖ Validate Invoices';
            }
        }


        // ===== VALIDATION PROCESSING =====
        async function processValidation() {
            try {
                showNotification('Processing validation...', 'info');
                
                // Initialize I2E data if not uploaded (use cache data)
                if (!validationData.i2eData) {
                    // Get invoices from cache (pending + approved only for validation)
                    const cachedInvoices = getInvoicesForValidation();
                    
                    if (cachedInvoices && cachedInvoices.length > 0) {
                        // Convert cache format to validation format
                        const i2eData = [];
                        cachedInvoices.forEach(invoice => {
                            if (invoice.fullInvoiceData && Array.isArray(invoice.fullInvoiceData)) {
                                i2eData.push(...invoice.fullInvoiceData);
                            } else if (invoice.summary) {
                                // For approved invoices, create minimal data from summary
                                i2eData.push({
                                    fileName: invoice.summary.fileName || 'cached_invoice.pdf',
                                    invoiceNumber: invoice.invoiceNumber,
                                    projectId: invoice.summary.projectId,
                                    customerId: invoice.summary.customerId || '',
                                    dateOfInvoice: invoice.summary.invoiceDate,
                                    monthOfInvoice: invoice.summary.monthOfInvoice,
                                    currency: invoice.summary.currency || 'EUR',
                                    extractedInvoiceTotal: invoice.summary.totalAmount,
                                    creditNote: invoice.summary.creditNote || false,
                                    approvalStatus: invoice.status
                                });
                            }
                        });
                        
                        validationData.i2eData = i2eData; // This is already an array
                        
                        // Add cache data as a "file" source
                        const currentTime = new Date().toLocaleString();
                        validationData.sourceFiles.i2e.push({
                            fileName: `${i2eData.length} invoices from cache`,
                            uploadTime: currentTime,
                            fileModified: 'From cache',
                            rowCount: i2eData.length,
                            tabName: 'Cache Data'
                        });
                        
                        updateFileInfo('i2e');
                        console.log('‚úÖ Using cached I2E data:', i2eData.length, 'invoices');
                    } else {
                        showNotification('No I2E invoice data available. Please process invoices first or upload an Excel file.', 'warning');
                        return;
                    }
                }
                
                // Consolidate and deduplicate all loaded data
                consolidateAndDeduplicateData();
                
                // Process the validation logic
                const results = processValidationLogic();
                validationData.processedResults = results;
                
                // Display results
                displayValidationResults(results);
                
                // Refresh Pending Invoices table now that cost data is loaded
                const pendingInvoices = await getPendingInvoices();
                displayPendingInvoices(pendingInvoices);
                console.log('üîÑ Refreshed Pending Invoices table with cost data');
                
                // Update tab button states now that cost data is available
                updateTabButtonStates();
                
                showNotification('Validation completed successfully', 'success');
                
            } catch (error) {
                console.error('Error during validation:', error);
                showNotification('Error during validation: ' + error.message, 'error');
            }
        }

        function processValidationLogic() {
            // Aggregate data by WBS code
            const wbsMap = new Map();
            
            console.log('üîç Starting validation logic...');
            console.log('üìä Available data sources:', {
                ppm: validationData.ppmData ? validationData.ppmData.length : 0,
                extSap: validationData.extSapData ? validationData.extSapData.length : 0,
                i2e: validationData.i2eData ? validationData.i2eData.length : 0
            });
            
            // Process PPM data (internal costs)
            if (validationData.ppmData) {
                console.log('üìã Processing PPM data...');
                console.log('üìã PPM columns:', Object.keys(validationData.ppmData[0] || {}));
                console.log('üìã PPM sample row:', validationData.ppmData[0]);
                
                validationData.ppmData.forEach(row => {
                    // Support both CTC (WBS Element ID) and RTC (Project) formats
                    const wbs = standardizeWBS(row['WBS Element ID'] || row['Project'] || row.project);
                    if (!wbs) return;
                    
                    if (!wbsMap.has(wbs)) {
                        wbsMap.set(wbs, {
                            wbsCode: wbs,
                            projectName: row['Project Name'] || row.projectName || row['Project'] || row.project || 'Unknown Project',
                            internalCost: 0,
                            externalCost: 0,
                            invoicedAmount: 0
                        });
                    }
                    
                    const cost = parseExcelNumericValue(row['Cost ‚Ç¨']);
                    wbsMap.get(wbs).internalCost += cost;
                });
                console.log(`‚úÖ Processed ${validationData.ppmData.length} PPM rows`);
            }
            
            // Process EXT SAP data (external costs)
            if (validationData.extSapData) {
                console.log('üìä Processing EXT SAP data...');
                console.log('üìä EXT SAP columns:', Object.keys(validationData.extSapData[0] || {}));
                console.log('üìä EXT SAP sample row:', validationData.extSapData[0]);
                
                let processedCount = 0;
                validationData.extSapData.forEach(row => {
                    // Support all 3 RTC scenarios: full WBS, partial in WBS Element, or partial in Project column
                    const wbs = standardizeWBS(row['WBS Element'] || row['WBS Element ID'] || row['WBS'] || row['Project'] || row.project);
                    if (!wbs) {
                        console.log('‚ùå No WBS found in row (tried: WBS Element, WBS Element ID, WBS, Project):', row);
                        return; // Skip this row, continue with next row
                    }
                    
                    // Document type filter removed as requested
                    
                    if (!wbsMap.has(wbs)) {
                        wbsMap.set(wbs, {
                            wbsCode: wbs,
                            projectName: row['CO object name'] || row['Project Name'] || row.projectName || row['Project'] || row.project || 'Unknown Project',
                            internalCost: 0,
                            externalCost: 0,
                            invoicedAmount: 0
                        });
                    }
                    
                    const cost = parseExcelNumericValue(row['Value']);
                    wbsMap.get(wbs).externalCost += cost;
                    processedCount++;
                    
                    if (processedCount <= 3) {
                        console.log(`üí∞ EXT SAP: WBS ${wbs}, Cost ${cost}`);
                    }
                });
                console.log(`‚úÖ Processed ${processedCount} EXT SAP rows (filtered from ${validationData.extSapData.length})`);
            }
            
            // Process cached invoice data (invoiced amounts) - use same logic as Pending Invoices tab
            const cachedInvoices = getAllInvoices(); // Get all cached invoices (pending, approved, rejected)
            if (cachedInvoices && cachedInvoices.length > 0) {
                console.log('üßæ Processing cached invoice data...');
                console.log('üßæ Cached invoices:', cachedInvoices.length);
                
                let processedCount = 0;
                cachedInvoices.forEach(invoice => {
                    // Get project ID from invoice
                    const projectId = getProjectId(invoice);
                    const wbs = standardizeWBS(projectId);
                    if (!wbs) {
                        console.log('‚ùå No project ID found in cached invoice:', invoice.invoiceNumber);
                        return;
                    }
                    
                    if (!wbsMap.has(wbs)) {
                        wbsMap.set(wbs, {
                            wbsCode: wbs,
                            projectName: 'No internal or external cost found for this WBS',
                            internalCost: 0,
                            externalCost: 0,
                            invoicedAmount: 0
                        });
                    }
                    
                    // Use the same getInvoiceTotal function as Pending Invoices tab
                    let amount = getInvoiceTotal(invoice);
                    
                    // Handle credit notes: check if any line item is a credit note
                    const isCreditNote = invoice.fullInvoiceData && invoice.fullInvoiceData.some(item => 
                        item.creditNote || (item.fileName && item.fileName.toLowerCase().includes('credit'))
                    );
                    
                    if (isCreditNote && amount > 0) {
                        amount = -Math.abs(amount);
                        if (processedCount <= 3) {
                            console.log(`üîÑ Credit note detected: converted ${Math.abs(amount)} to ${amount} for WBS ${wbs}`);
                        }
                    }
                    
                    wbsMap.get(wbs).invoicedAmount += amount;
                    processedCount++;
                    
                    if (processedCount <= 3) {
                        console.log(`üíµ Invoice ${invoice.invoiceNumber}: WBS ${wbs}, Amount ${amount}${isCreditNote ? ' (Credit Note)' : ''}`);
                    }
                });
                console.log(`‚úÖ Processed ${processedCount} cached invoices`);
            }
            
            // Convert to array and calculate deltas
            const results = Array.from(wbsMap.values()).map(item => {
                item.totalCost = item.internalCost + item.externalCost;
                item.delta = item.totalCost - item.invoicedAmount;
                return item;
            });
            
            // Sort by WBS code
            results.sort((a, b) => a.wbsCode.localeCompare(b.wbsCode));
            
            console.log('üîç Validation results:', results);
            return results;
        }

        function standardizeWBS(wbsCode) {
            if (!wbsCode) return null;
            return wbsCode.toString().replace(/-EXN$/, '').trim().toUpperCase();
        }

        // ===== RESULTS DISPLAY =====
        function displayValidationResults(results) {
            const container = document.getElementById('validationResults');
            const tbody = document.getElementById('validationTableBody');
            
            tbody.innerHTML = '';
            
            results.forEach(item => {
                const row = document.createElement('tr');
                
                // Color coding based on delta and cost availability
                if (item.internalCost === 0 && item.externalCost === 0) {
                    row.style.backgroundColor = '#fef3c7'; // Yellow for no costs found
                } else if (Math.abs(item.delta) < 0.01) {
                    row.style.backgroundColor = '#d1fae5'; // Green for perfect match (delta = 0)
                } else if (item.delta < 0) {
                    row.style.backgroundColor = '#fee2e2'; // Red for negative delta
                }
                
                row.innerHTML = `
                    <td><input type="radio" name="selectedProject" value="${item.wbsCode}" onchange="onProjectSelected('${item.wbsCode}', '${item.projectName}')"></td>
                    <td>${item.wbsCode}</td>
                    <td>${item.projectName}</td>
                    <td>${formatCurrency(item.internalCost)}</td>
                    <td>${formatCurrency(item.externalCost)}</td>
                    <td><strong>${formatCurrency(item.totalCost)}</strong></td>
                    <td><strong>${formatCurrency(item.invoicedAmount)}</strong></td>
                    <td><strong>${item.delta >= 0 ? '+' : ''}${formatCurrency(item.delta)}</strong></td>
                `;
                
                tbody.appendChild(row);
            });
            
            container.style.display = 'block';
            
            // Apply the default pending invoices filter immediately
            setTimeout(() => {
                // Ensure checkbox is checked (should be by default but double-check)
                const pendingFilter = document.getElementById('pendingInvoicesFilter');
                if (pendingFilter) {
                    pendingFilter.checked = true;
                }
                filterProjects();
            }, 100);
            
            // Note: Invoice Details tab should only be shown when clicking Details for a single invoice
        }

        function showAdditionalTabs() {
            const detailsBtn = document.getElementById('detailsTabBtn');
            if (detailsBtn) {
                detailsBtn.style.display = '';
            }
        }

        function hideAdditionalTabs() {
            const detailsBtn = document.getElementById('detailsTabBtn');
            if (detailsBtn) {
                detailsBtn.style.display = 'none';
            }
            
            // Switch back to overview tab if we're on a hidden tab
            if (!document.getElementById('overviewTab').classList.contains('active')) {
                switchTab('overview');
            }
        }

        // ===== WBS CODE MATCHING =====
        function getWbsVariants(wbs) {
            if (!wbs) return [];
            
            const baseWbs = wbs.replace(/-EXN$/i, '').trim();
            const variants = [baseWbs];
            
            // Add -EXN variant if it doesn't already have it
            if (!wbs.toUpperCase().endsWith('-EXN')) {
                variants.push(baseWbs + '-EXN');
            }
            
            return variants;
        }
        
        function matchesAnyWbsVariant(targetWbs, searchWbs) {
            if (!targetWbs || !searchWbs) return false;
            
            const targetVariants = getWbsVariants(targetWbs);
            const searchVariants = getWbsVariants(searchWbs);
            
            // Check if any variant of target matches any variant of search
            return targetVariants.some(tv => 
                searchVariants.some(sv => tv === sv)
            );
        }

        // ===== PROJECT OVERVIEW MULTI-SELECT =====
        let overviewSelectedProjects = [];

        function updateProjectOverviewDropdown() {
            const filterInput = document.getElementById('projectFilter');
            const dropdown = document.getElementById('projectOverviewSelect');
            const filterText = filterInput.value.toLowerCase();
            
            if (!validationData.processedResults) {
                dropdown.innerHTML = '<option disabled>No validation data available</option>';
                return;
            }
            
            // Get all projects from validation results
            const allProjects = validationData.processedResults.map(result => ({
                wbs: result.wbsCode,
                name: result.projectName,
                displayText: `${result.projectName} (${result.wbsCode})`
            }));
            
            // Filter projects based on search text
            const filteredProjects = allProjects.filter(project =>
                !filterText || 
                project.name.toLowerCase().includes(filterText) ||
                project.wbs.toLowerCase().includes(filterText)
            );
            
            // Update dropdown options
            dropdown.innerHTML = '';
            filteredProjects.sort((a, b) => a.name.localeCompare(b.name)).forEach(project => {
                const option = document.createElement('option');
                option.value = `${project.wbs}|${project.name}`;
                option.textContent = project.displayText;
                option.selected = true; // Auto-select all filtered projects
                dropdown.appendChild(option);
            });
            
            // Auto-select all filtered projects
            if (filteredProjects.length > 0) {
                overviewSelectedProjects = filteredProjects.map(project => ({
                    wbs: project.wbs,
                    name: project.name
                }));
                
                // Apply the filter to update the display
                filterProjects();
            }
            
            console.log(`üìä Project overview dropdown updated: ${filteredProjects.length} projects available`);
        }

        function applyProjectOverviewSelection() {
            const dropdown = document.getElementById('projectOverviewSelect');
            overviewSelectedProjects = Array.from(dropdown.selectedOptions).map(option => {
                const parts = option.value.split('|');
                return {
                    wbs: parts[0],
                    name: parts[1] || parts[0]
                };
            });
            
            // Apply the filter to the table
            filterProjects();
        }

        function selectAllOverviewProjects() {
            const dropdown = document.getElementById('projectOverviewSelect');
            
            // Convert option values back to proper objects with wbs and name
            overviewSelectedProjects = Array.from(dropdown.options).map(option => {
                const parts = option.value.split('|');
                return {
                    wbs: parts[0],
                    name: parts[1] || parts[0]
                };
            });
            
            // Update visual selection
            Array.from(dropdown.options).forEach(option => option.selected = true);
            
            // Apply the filter
            filterProjects();
        }

        function deselectAllOverviewProjects() {
            const dropdown = document.getElementById('projectOverviewSelect');
            
            // Clear selected projects array
            overviewSelectedProjects = [];
            
            // Update visual selection
            Array.from(dropdown.options).forEach(option => option.selected = false);
            
            // Apply the filter
            filterProjects();
        }

        // ===== FILTER FUNCTIONALITY =====
        function autoSelectFilteredProjects() {
            const dropdown = document.getElementById('projectOverviewSelect');
            const tableBody = document.getElementById('validationTableBody');
            
            if (!dropdown || !tableBody) return;
            
            // Get all visible projects
            const visibleProjects = [];
            const visibleRows = tableBody.querySelectorAll('tr[style=""]');
            
            visibleRows.forEach(row => {
                const wbsCell = row.cells[1]; // WBS Code column
                const projectCell = row.cells[2]; // Project Name column
                
                if (wbsCell && projectCell) {
                    const wbs = wbsCell.textContent.trim();
                    const name = projectCell.textContent.trim();
                    visibleProjects.push({ wbs, name });
                }
            });
            
            // Auto-select all visible projects in dropdown
            Array.from(dropdown.options).forEach(option => {
                const optionValue = option.value.split('|')[0];
                option.selected = visibleProjects.some(proj => proj.wbs === optionValue);
            });
            
            // Update selected projects array
            overviewSelectedProjects = visibleProjects;
            
            // Auto-select the top invoice (first radio button)
            const firstRadio = tableBody.querySelector('input[type="radio"]');
            if (firstRadio) {
                firstRadio.checked = true;
                // Trigger the change event to enable the validate button
                firstRadio.dispatchEvent(new Event('change'));
            }
            
            console.log(`üéØ Auto-selected ${visibleProjects.length} projects and top invoice`);
        }

        async function filterProjects() {
            const projectFilter = document.getElementById('projectFilter').value.toLowerCase();
            const pendingInvoicesFilter = document.getElementById('pendingInvoicesFilter').checked;
            const tableBody = document.getElementById('validationTableBody');
            
            if (!tableBody) {
                console.log('üìä No validation table found');
                return;
            }
            
            const rows = tableBody.querySelectorAll('tr');
            let visibleCount = 0;
            
            // Get pending invoices to check which projects have pending invoices
            let projectsWithPendingInvoices = new Set();
            if (pendingInvoicesFilter) {
                const pendingInvoices = await getPendingInvoices();
                pendingInvoices.forEach(invoice => {
                    const projectId = getProjectId(invoice);
                    if (projectId) {
                        projectsWithPendingInvoices.add(standardizeWBS(projectId));
                    }
                });
            }
            
            rows.forEach(row => {
                const wbsCell = row.cells[1]; // WBS Code column (index 1 because of radio button column)
                const projectCell = row.cells[2]; // Project Name column (index 2)
                
                if (wbsCell && projectCell) {
                    const wbsCode = wbsCell.textContent.trim();
                    const projectName = projectCell.textContent.toLowerCase();
                    
                    // Check text filter (search in both name and WBS)
                    const textMatch = !projectFilter || 
                        projectName.includes(projectFilter) || 
                        wbsCode.toLowerCase().includes(projectFilter);
                    
                    // Check multi-select filter
                    const multiSelectMatch = overviewSelectedProjects.length === 0 || 
                        overviewSelectedProjects.some(proj => 
                            (typeof proj === 'string' ? proj : proj.wbs) === wbsCode
                        );
                    
                    // Check pending invoices filter
                    const pendingMatch = !pendingInvoicesFilter || projectsWithPendingInvoices.has(wbsCode);
                    
                    const shouldShow = textMatch && multiSelectMatch && pendingMatch;
                    row.style.display = shouldShow ? '' : 'none';
                    if (shouldShow) {
                        visibleCount++;
                    }
                }
            });
            
            // Auto-select all visible projects and top invoice when filter is applied
            if (projectFilter && visibleCount > 0) {
                autoSelectFilteredProjects();
            }
            
            // Show filter results
            const filterResults = document.getElementById('filterResults');
            const totalRows = rows.length;
            
            if (projectFilter || overviewSelectedProjects.length > 0 || pendingInvoicesFilter) {
                let filterDescription = '';
                
                if (projectFilter) filterDescription += `text: "${projectFilter}"`;
                if (overviewSelectedProjects.length > 0) {
                    if (filterDescription) filterDescription += ', ';
                    filterDescription += `${overviewSelectedProjects.length} selected projects`;
                }
                if (pendingInvoicesFilter) {
                    if (filterDescription) filterDescription += ', ';
                    filterDescription += 'pending invoices only';
                }
                
                filterResults.innerHTML = `Showing ${visibleCount} of ${totalRows} projects (${filterDescription})`;
                filterResults.style.display = 'block';
            } else {
                filterResults.style.display = 'none';
            }
            
            console.log(`üîç Filter applied: ${visibleCount}/${totalRows} projects visible`);
        }

        function clearProjectFilter() {
            document.getElementById('projectFilter').value = '';
            
            // Update dropdown first
            updateProjectOverviewDropdown();
            
            // Auto-select all projects after clearing filter
            selectAllOverviewProjects();
        }


        // ===== TABLE SORTING FUNCTIONALITY =====
        let sortDirection = {};
        
        function sortTable(columnIndex) {
            const table = document.getElementById('validationTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Determine sort direction - start with descending on first click
            const currentDirection = sortDirection[columnIndex] || 'desc';
            const newDirection = currentDirection === 'desc' ? 'asc' : 'desc';
            sortDirection[columnIndex] = newDirection;
            
            // Update header indicators - show sort direction
            const headers = table.querySelectorAll('th');
            headers.forEach((header, index) => {
                if (index < 7) { // Only update sortable columns
                    const originalText = header.textContent.replace(/[‚Üë‚Üì‚ÜïÔ∏è]/g, '').trim();
                    
                    if (index === columnIndex) {
                        const arrow = newDirection === 'asc' ? '‚Üë' : '‚Üì';
                        header.innerHTML = `${originalText} ${arrow}`;
                    } else {
                        header.innerHTML = `${originalText} ‚ÜïÔ∏è`;
                    }
                }
            });
            
            // Sort rows
            rows.sort((a, b) => {
                let aValue = a.cells[columnIndex].textContent.trim();
                let bValue = b.cells[columnIndex].textContent.trim();
                
                // Handle currency values (remove currency symbols and convert to numbers)
                if (columnIndex >= 2 && columnIndex <= 6) {
                    aValue = parseFloat(aValue.replace(/[‚Ç¨,+\s]/g, '').replace(/^-/, '-')) || 0;
                    bValue = parseFloat(bValue.replace(/[‚Ç¨,+\s]/g, '').replace(/^-/, '-')) || 0;
                    
                    if (newDirection === 'asc') {
                        return aValue - bValue;
                    } else {
                        return bValue - aValue;
                    }
                } else {
                    // Handle text values
                    if (newDirection === 'asc') {
                        return aValue.localeCompare(bValue);
                    } else {
                        return bValue.localeCompare(aValue);
                    }
                }
            });
            
            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        // ===== INVOICE DETAILS FUNCTIONALITY =====
        
        async function loadInvoiceDetails(invoiceNumber) {
            console.log(`üîç Loading details for invoice: ${invoiceNumber}`);
            
            const detailsContent = document.getElementById('detailsContent');
            const detailsPlaceholder = document.getElementById('detailsPlaceholder');
            
            // Find the invoice in pending invoices
            const pendingInvoices = await getPendingInvoices();
            console.log('üîç All pending invoices:', pendingInvoices);
            const invoice = pendingInvoices.find(inv => inv.invoiceNumber === invoiceNumber);
            console.log('üîç Found invoice for details:', invoice);
            
            if (!invoice) {
                // Show placeholder and clear content
                if (detailsPlaceholder) detailsPlaceholder.style.display = 'block';
                detailsContent.innerHTML = `
                    <div class="card">
                        <h4>‚ùå Invoice Not Found</h4>
                        <p>Invoice ${invoiceNumber} not found in pending invoices.</p>
                    </div>
                `;
                return;
            }
            
            // Hide placeholder when showing content
            if (detailsPlaceholder) detailsPlaceholder.style.display = 'none';
            
            // Check for multiple invoices in same project/month
            const invoiceData = invoice.fullInvoiceData && invoice.fullInvoiceData[0] ? invoice.fullInvoiceData[0] : {};
            const projectId = invoiceData.projectId || 'Unknown';
            const monthOfInvoice = invoiceData.monthOfInvoice || 'Unknown';
            
            if (projectId !== 'Unknown' && monthOfInvoice !== 'Unknown') {
                const otherInvoices = checkForMultipleInvoicesInMonth(invoiceNumber, projectId, monthOfInvoice);
                if (otherInvoices.length > 0) {
                    showMultipleInvoiceNotification(invoiceNumber, otherInvoices, projectId, monthOfInvoice);
                }
            }
            
            // Generate the detailed analysis
            const detailsHtml = generateInvoiceDetailsHtml(invoice);
            detailsContent.innerHTML = detailsHtml;
        }
        
        function generateInvoiceDetailsHtml(invoice) {
            const invoiceNumber = invoice.invoiceNumber;
            const invoiceData = invoice.fullInvoiceData && invoice.fullInvoiceData[0] ? invoice.fullInvoiceData[0] : {};
            const projectId = invoiceData.projectId || 'Unknown';
            const wbsCode = standardizeWBS(projectId);
            const invoiceDate = invoiceData.dateOfInvoice || 'Unknown';
            const monthOfInvoice = invoiceData.monthOfInvoice || 'Unknown';
            const invoiceTotal = invoiceData.extractedInvoiceTotal || 0;
            const creditNote = invoiceData.creditNote || false;
            
            // Calculate costs using the same logic as pending invoices table
            const costs = calculateInvoiceCosts(invoice, monthOfInvoice);
            
            // Get detailed cost breakdown
            const costBreakdown = getDetailedCostBreakdown(invoice, monthOfInvoice);
            
            return `
                <!-- Invoice Summary Card -->
                <div class="card" style="margin-bottom: 1.5rem; padding: 0.8rem; ${creditNote ? 'background: #f0f9ff; border-left: 4px solid #0ea5e9;' : ''}">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 2rem; margin: 0.5rem 0;">
                        <div>
                            <strong>Project:</strong><br>
                            <span style="font-family: monospace;">${projectId}</span>
                        </div>
                        <div>
                            <strong>Invoice Date:</strong><br>
                            ${invoiceDate}<br>
                            <small>Month: ${monthOfInvoice}</small>
                        </div>
                        <div>
                            <strong>Total Amount:</strong><br>
                            <span style="font-size: 1.2rem; font-weight: bold; color: ${creditNote ? '#0ea5e9' : '#059669'};">
                                ${formatCurrency(invoiceTotal)} ${invoiceData.currency || 'EUR'}
                            </span><br>
                            <small>${creditNote ? 'Credit Note' : 'Invoice'}</small>
                        </div>
                    </div>
                </div>
                
                <!-- Cost Comparison Card -->
                <div class="card" style="margin-bottom: 1.5rem;">
                    <h4>üí∞ Cost Comparison (Month: ${monthOfInvoice})</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 2rem; margin: 1rem 0;">
                        <div>
                            <strong>Internal Cost (PPM):</strong><br>
                            <span style="font-size: 1.1rem; font-weight: bold;">
                                ${formatCurrency(costs.internalCost)} EUR
                            </span><br>
                            <small>From PPM data</small>
                        </div>
                        <div>
                            <strong>External Cost (EXT SAP):</strong><br>
                            <span style="font-size: 1.1rem; font-weight: bold;">
                                ${formatCurrency(costs.externalCost)} EUR
                            </span><br>
                            <small>From EXT SAP data</small>
                        </div>
                        <div>
                            <strong>Total cost:</strong><br>
                            <span style="font-size: 1.1rem; font-weight: bold;">
                                ${formatCurrency(costs.totalCost)} EUR
                            </span><br>
                            <small>PPM + EXT SAP</small>
                        </div>
                        <div>
                            <strong>Total cost -/- Invoice:</strong><br>
                            <span style="font-size: 1.1rem; font-weight: bold; color: ${Math.abs(invoiceTotal - costs.totalCost) < 0.01 ? '#059669' : ((invoiceTotal - costs.totalCost) < 0 ? '#dc2626' : 'inherit')};">
                                ${invoiceTotal - costs.totalCost >= 0 ? '+' : ''}${formatCurrency(invoiceTotal - costs.totalCost)} EUR
                            </span><br>
                            <small>${Math.abs(invoiceTotal - costs.totalCost) < 0.01 ? 'Match' : 'Variance'}</small>
                        </div>
                    </div>
                </div>
                
                <!-- Invoice Line Items -->
                ${generateInvoiceLineItemsHtml(invoice)}
                
                <!-- Detailed Cost Breakdown -->
                ${generateDetailedCostBreakdownHtml(costBreakdown, monthOfInvoice)}
                
                <!-- Actions -->
                <div class="card" style="text-align: center;">
                    <h4>üéØ Actions</h4>
                    <div style="display: flex; justify-content: center; gap: 1rem;">
                        <button class="btn btn-success" onclick="handleApproveInvoice('${invoiceNumber}')">
                            ‚úÖ Approve Invoice
                        </button>
                        <button class="btn btn-warning" onclick="handleRejectInvoice('${invoiceNumber}')">
                            ‚ùå Reject Invoice  
                        </button>
                    </div>
                </div>
            `;
        }
        
        function generateInvoiceLineItemsHtml(invoice) {
            console.log('üîç generateInvoiceLineItemsHtml called with invoice:', invoice);
            console.log('üîç invoice.fullInvoiceData:', invoice.fullInvoiceData);
            console.log('üîç invoice.fullInvoiceData is array?', Array.isArray(invoice.fullInvoiceData));
            console.log('üîç invoice.fullInvoiceData length:', invoice.fullInvoiceData ? invoice.fullInvoiceData.length : 'undefined');
            
            if (!invoice.fullInvoiceData || !Array.isArray(invoice.fullInvoiceData)) {
                console.log('‚ùå No line item data available or not array');
                return '<div class="card"><h4>üìã Line Items</h4><p>No line item data available.</p></div>';
            }
            
            // Handle nested fullInvoiceData structure
            let lineItems = invoice.fullInvoiceData;
            
            // Check if we have a nested structure where fullInvoiceData[0] contains the actual line items
            if (lineItems.length === 1 && lineItems[0].fullInvoiceData && Array.isArray(lineItems[0].fullInvoiceData)) {
                console.log('üîç Detected nested structure, using inner fullInvoiceData');
                lineItems = lineItems[0].fullInvoiceData;
            }
            
            console.log('üîç Final line items to process:', lineItems);
            console.log('üîç Final line items count:', lineItems.length);
            
            // Group line items by cost type
            const groupedItems = {
                'Internal': [],
                'External': [],
                'Unknown': []
            };
            
            lineItems.forEach(item => {
                const costType = item.typeCost || 'Unknown';
                if (!groupedItems[costType]) {
                    groupedItems[costType] = [];
                }
                groupedItems[costType].push(item);
            });
            
            // Calculate totals for each group
            const groupTotals = {};
            Object.keys(groupedItems).forEach(costType => {
                groupTotals[costType] = groupedItems[costType].reduce((sum, item) => {
                    return sum + (item.positionTotal || 0);
                }, 0);
            });
            
            let html = `
                <div class="card" style="margin-bottom: 1.5rem;">
                    <h4>üìã Invoice Line Items (${lineItems.length} items)</h4>
            `;
            
            // Generate expandable sections for each cost type
            Object.keys(groupedItems).forEach(costType => {
                const items = groupedItems[costType];
                if (items.length === 0) return;
                
                const cssClass = costType.toLowerCase().replace(/[^a-zA-Z0-9]/g, '');
                const costTypeIcon = costType === 'Internal' ? 'üë•' : costType === 'External' ? 'üè¢' : '‚ùì';
                
                html += `
                    <div class="cost-type-section" style="margin-bottom: 1rem; border: 1px solid #e2e8f0; border-radius: 8px;">
                        <div class="cost-type-header" style="padding: 1rem; background: #f8fafc; border-bottom: 1px solid #e2e8f0; cursor: pointer;" onclick="toggleCostType('${cssClass}')">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <button class="expand-btn" style="background: none; border: none; font-size: 1.2rem; cursor: pointer;">‚ñº</button>
                                    <span style="font-weight: bold;">${costTypeIcon} ${costType} Costs</span>
                                    <span style="color: #666; font-size: 0.9rem;">(${items.length} items)</span>
                                </div>
                                <div style="font-weight: bold; color: #059669;">
                                    ${formatCurrency(groupTotals[costType])} EUR
                                </div>
                            </div>
                        </div>
                        
                        <div class="cost-type-content cost-type-${cssClass}" style="display: none;">
                            <div style="overflow-x: auto;">
                                <table class="data-table" style="min-width: 1000px; margin: 0;">
                                    <thead>
                                        <tr>
                                            <th>Position</th>
                                            <th>Material</th>
                                            <th>Description</th>
                                            <th>Quantity</th>
                                            <th>Unit</th>
                                            <th>Unit Price</th>
                                            <th>Total</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                `;
                
                items.forEach(item => {
                    const isCreditNote = item.creditNote || false;
                    const rowStyle = isCreditNote ? 'background-color: #f0f9ff;' : '';
                    
                    html += `
                        <tr style="${rowStyle}">
                            <td>${item.position || '-'}</td>
                            <td>${item.material || '-'}</td>
                            <td style="max-width: 300px;">${item.positionDescription || '-'}</td>
                            <td>${item.positionQuantity || '-'}</td>
                            <td>${item.unit || '-'}</td>
                            <td>${formatCurrency(item.unitPrice || 0)}</td>
                            <td><strong>${formatCurrency(item.positionTotal || 0)}</strong></td>
                        </tr>
                    `;
                });
                
                html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `
                </div>
            `;
            
            return html;
        }
        
        function getDetailedCostBreakdown(invoice, monthOfInvoice) {
            const projectId = getProjectId(invoice);
            const wbsCode = standardizeWBS(projectId);
            const invoiceDate = getInvoiceDate(invoice);
            
            const breakdown = {
                ppmData: [],
                extSapData: [],
                filters: {
                    wbsCode: wbsCode,
                    monthOfInvoice: monthOfInvoice,
                    invoiceDate: invoiceDate
                }
            };
            
            // Get PPM data matches
            if (validationData.ppmData) {
                const invoiceMonthName = monthOfInvoice ? monthOfInvoice.split(' ')[0] : null;
                
                validationData.ppmData.forEach(row => {
                    // Support both CTC (WBS Element ID) and RTC (Project) formats
                    const rowWbs = standardizeWBS(row['WBS Element ID'] || row['Project'] || row.project);
                    const rowMonthOfInvoice = row['Month of invoice'];
                    
                    if (rowWbs === wbsCode && rowMonthOfInvoice === invoiceMonthName) {
                        breakdown.ppmData.push({
                            wbs: rowWbs,
                            month: rowMonthOfInvoice,
                            user: row.User || '-',
                            role: row['Role 2025'] || '-',
                            rate: row['Rate 2025'] || 0,
                            cost: parseExcelNumericValue(row['Cost ‚Ç¨']),
                            project: row['Project Name'] || '-'
                        });
                    }
                });
            }
            
            // Get EXT SAP data matches
            if (validationData.extSapData) {
                let targetPeriod = null;
                let targetFiscalYear = null;
                
                if (invoiceDate && invoiceDate !== 'Unknown') {
                    const dateParts = invoiceDate.split('.');
                    if (dateParts.length >= 3) {
                        targetPeriod = parseInt(dateParts[1]);
                        targetFiscalYear = parseInt(dateParts[2]);
                    }
                }
                
                if (targetPeriod && targetFiscalYear) {
                    validationData.extSapData.forEach(row => {
                        // Support all 3 RTC scenarios: full WBS, partial in WBS Element, or partial in Project column
                        const rowWbs = standardizeWBS(row['WBS Element'] || row['WBS Element ID'] || row['WBS'] || row['Project'] || row.project);
                        const period = parseInt(row['Period']);
                        const fiscalYear = parseInt(row['Fiscal Year']);
                        
                        if (rowWbs === wbsCode && period === targetPeriod && fiscalYear === targetFiscalYear) {
                            breakdown.extSapData.push({
                                wbs: rowWbs,
                                period: period,
                                fiscalYear: fiscalYear,
                                supplier: row['Name of offsetting account'] || '-',
                                value: parseExcelNumericValue(row.Value),
                                documentDate: row['Document Date'] || '-',
                                documentType: row['Document type'] || '-',
                                refDocumentNumber: row['Ref. document number'] || '-',
                                documentNumber: row['Document Number'] || '-'
                            });
                        }
                    });
                }
            }
            
            return breakdown;
        }
        
        function generateDetailedCostBreakdownHtml(breakdown, monthOfInvoice) {
            let html = `
                <div class="card" style="margin-bottom: 1.5rem;">
                    <h4>üîç Detailed Cost Breakdown (${monthOfInvoice})</h4>
                    <p style="margin-bottom: 1rem;">
                        <strong>Filters Applied:</strong> WBS = ${breakdown.filters.wbsCode}, 
                        Month = ${monthOfInvoice}, Date = ${breakdown.filters.invoiceDate}
                    </p>
            `;
            
            // PPM Data Table
            html += `
                <h5 style="color: #7c3aed; margin-top: 1.5rem;">üìã PPM Data Matches (${breakdown.ppmData.length} rows)</h5>
            `;
            
            if (breakdown.ppmData.length > 0) {
                html += `
                    <div style="overflow-x: auto;">
                        <table class="data-table" style="min-width: 800px;">
                            <thead>
                                <tr>
                                    <th>User</th>
                                    <th>Role</th>
                                    <th>Rate</th>
                                    <th>Cost ‚Ç¨</th>
                                    <th>Month</th>
                                    <th>Project</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                breakdown.ppmData.forEach(item => {
                    html += `
                        <tr>
                            <td>${item.user}</td>
                            <td>${item.role}</td>
                            <td>${formatCurrency(item.rate)}</td>
                            <td><strong>${formatCurrency(item.cost)}</strong></td>
                            <td>${item.month}</td>
                            <td style="max-width: 200px;">${item.project}</td>
                        </tr>
                    `;
                });
                
                const totalPPM = breakdown.ppmData.reduce((sum, item) => sum + item.cost, 0);
                html += `
                        <tr style="background-color: #f3f4f6; font-weight: bold;">
                            <td colspan="3">Total Internal Cost</td>
                            <td><strong>${formatCurrency(totalPPM)}</strong></td>
                            <td colspan="2"></td>
                        </tr>
                `;
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            } else {
                html += '<p style="color: #6b7280; font-style: italic;">No PPM data found for this month/project combination.</p>';
            }
            
            // EXT SAP Data Table
            html += `
                <h5 style="color: #dc2626; margin-top: 1.5rem;">üìä EXT SAP Data Matches (${breakdown.extSapData.length} rows)</h5>
            `;
            
            if (breakdown.extSapData.length > 0) {
                html += `
                    <div style="overflow-x: auto;">
                        <table class="data-table" style="min-width: 800px;">
                            <thead>
                                <tr>
                                    <th>Fiscal Year</th>
                                    <th>Period</th>
                                    <th>Supplier</th>
                                    <th>Value ‚Ç¨</th>
                                    <th>Doc Date</th>
                                    <th>Doc Type</th>
                                    <th>Ref</th>
                                    <th>Doc</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                breakdown.extSapData.forEach(item => {
                    html += `
                        <tr>
                            <td>${item.fiscalYear}</td>
                            <td>${item.period}</td>
                            <td style="max-width: 200px;">${item.supplier || '-'}</td>
                            <td><strong>${formatCurrency(item.value)}</strong></td>
                            <td>${item.documentDate ? item.documentDate.split('T')[0] : '-'}</td>
                            <td>${item.documentType}</td>
                            <td>${item.refDocumentNumber || '-'}</td>
                            <td>${item.documentNumber || '-'}</td>
                        </tr>
                    `;
                });
                
                const totalExtSap = breakdown.extSapData.reduce((sum, item) => sum + item.value, 0);
                html += `
                        <tr style="background-color: #f3f4f6; font-weight: bold;">
                            <td colspan="3">Total External Cost</td>
                            <td><strong>${formatCurrency(totalExtSap)}</strong></td>
                            <td colspan="4"></td>
                        </tr>
                `;
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            } else {
                html += '<p style="color: #6b7280; font-style: italic;">No EXT SAP data found for this month/project combination.</p>';
            }
            
            html += '</div>';
            return html;
        }

        // ===== UTILITY FUNCTIONS =====

        function exportValidationResults() {
            if (!validationData.processedResults) {
                showNotification('No validation results to export', 'warning');
                return;
            }
            
            // This will be implemented using the existing Excel export functionality
            showNotification('Export functionality will be implemented soon', 'info');
        }

        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', function() {
            console.log('I2E Invoice Validator loaded');
            
            // Upload zone setup removed - data now uploaded in index screen
            
            // Check if we have recent I2E data
            if (typeof extractedData !== 'undefined' && extractedData.length > 0) {
                const currentTime = new Date().toLocaleString();
                updateFileInfo('i2e', `${extractedData.length} invoices processed`, currentTime, 'success');
                checkReadyToProcess();
            }
        });

        // ===== PENDING INVOICES HELPER FUNCTIONS =====
        
        function getMonthOfInvoice(invoice) {
            if (invoice.fullInvoiceData && invoice.fullInvoiceData[0]) {
                return invoice.fullInvoiceData[0].monthOfInvoice || 'Unknown';
            }
            if (invoice.summary) {
                return invoice.summary.monthOfInvoice || 'Unknown';
            }
            return 'Unknown';
        }
        
        function getInvoiceDate(invoice) {
            if (invoice.fullInvoiceData && invoice.fullInvoiceData[0]) {
                return invoice.fullInvoiceData[0].dateOfInvoice || 'Unknown';
            }
            if (invoice.summary) {
                return invoice.summary.invoiceDate || 'Unknown';
            }
            return 'Unknown';
        }
        
        function calculateInvoiceCosts(invoice, monthOfInvoice) {
            const projectId = getProjectId(invoice);
            const wbsCode = standardizeWBS(projectId);
            const invoiceDate = getInvoiceDate(invoice);
            
            let internalCost = 0;
            let externalCost = 0;
            
            console.log(`üîç Calculating costs for invoice ${getInvoiceNumber(invoice)}: WBS=${wbsCode}, Month=${monthOfInvoice}, Date=${invoiceDate}`);
            
            // Process PPM data (internal costs) - FILTER BY MONTH OF INVOICE
            if (validationData.ppmData) {
                // Extract just the month name from monthOfInvoice (e.g., "April 2025" -> "April")
                const invoiceMonthName = monthOfInvoice ? monthOfInvoice.split(' ')[0] : null;
                console.log(`üîç PPM Filtering: Looking for WBS=${wbsCode}, Month=${invoiceMonthName} (from ${monthOfInvoice})`);
                console.log(`üîç PPM Data available: ${validationData.ppmData.length} rows`);
                
                let ppmChecked = 0;
                let ppmMatches = 0;
                
                validationData.ppmData.forEach(row => {
                    // Support both CTC (WBS Element ID) and RTC (Project) formats
                    const rowWbs = standardizeWBS(row['WBS Element ID'] || row['Project'] || row.project);
                    const rowMonthOfInvoice = row['Month of invoice']; // Format: "April"
                    
                    ppmChecked++;
                    if (ppmChecked <= 5) {
                        console.log(`üîç PPM Row ${ppmChecked}: WBS=${rowWbs}, Month=${rowMonthOfInvoice}`);
                    }
                    
                    // Match both WBS and Month name only (not year)
                    if (rowWbs === wbsCode && rowMonthOfInvoice === invoiceMonthName) {
                        const cost = parseExcelNumericValue(row['Cost ‚Ç¨']);
                        internalCost += cost;
                        ppmMatches++;
                        
                        console.log(`‚úÖ PPM match ${ppmMatches}: WBS=${rowWbs}, Month=${rowMonthOfInvoice}, Cost=${cost}`);
                    }
                });
                
                console.log(`üìä PPM Summary: Checked ${ppmChecked} rows, found ${ppmMatches} matches, Total Internal Cost: ${internalCost}`);
            } else {
                console.log(`‚ùå PPM data not available for filtering`);
            }
            
            // Process EXT SAP data (external costs) - FILTER BY PERIOD AND FISCAL YEAR
            if (validationData.extSapData) {
                // Extract month and year from invoice date (format: dd.mm.yyyy)
                let targetPeriod = null;
                let targetFiscalYear = null;
                
                if (invoiceDate && invoiceDate !== 'Unknown') {
                    const dateParts = invoiceDate.split('.');
                    if (dateParts.length >= 3) {
                        targetPeriod = parseInt(dateParts[1]); // Month as number (04 -> 4)
                        targetFiscalYear = parseInt(dateParts[2]); // Year (2025)
                    }
                }
                
                if (targetPeriod && targetFiscalYear) {
                    console.log(`üîç EXT SAP Filtering: Looking for WBS=${wbsCode}, Period=${targetPeriod}, FiscalYear=${targetFiscalYear}`);
                    console.log(`üîç EXT SAP Data available: ${validationData.extSapData.length} rows`);
                    
                    let extSapChecked = 0;
                    let extSapMatches = 0;
                    
                    validationData.extSapData.forEach(row => {
                        // Support all 3 RTC scenarios: full WBS, partial in WBS Element, or partial in Project column
                        const rowWbs = standardizeWBS(row['WBS Element'] || row['WBS Element ID'] || row['WBS'] || row['Project'] || row.project);
                        const period = parseInt(row['Period']); // Month as number
                        const fiscalYear = parseInt(row['Fiscal Year']); // Year
                        
                        extSapChecked++;
                        if (extSapChecked <= 5) {
                            console.log(`üîç EXT SAP Row ${extSapChecked}: WBS=${rowWbs}, Period=${period}, FiscalYear=${fiscalYear}`, {
                                'Raw WBS Sources': {
                                    'WBS Element': row['WBS Element'],
                                    'WBS Element ID': row['WBS Element ID'], 
                                    'WBS': row['WBS'],
                                    'Project': row['Project'],
                                    'project': row.project
                                },
                                'Target': `WBS=${wbsCode}, Period=${targetPeriod}, FiscalYear=${targetFiscalYear}`
                            });
                        }
                        
                        // Match WBS, Period (month), and Fiscal Year
                        if (rowWbs === wbsCode && period === targetPeriod && fiscalYear === targetFiscalYear) {
                            const cost = parseExcelNumericValue(row.Value);
                            externalCost += cost;
                            extSapMatches++;
                            
                            console.log(`‚úÖ EXT SAP match ${extSapMatches}: WBS=${rowWbs}, Period=${period}, FiscalYear=${fiscalYear}, Cost=${cost}`);
                        }
                    });
                    
                    console.log(`üìä EXT SAP Summary: Checked ${extSapChecked} rows, found ${extSapMatches} matches, Total External Cost: ${externalCost}`);
                } else {
                    console.log(`‚ùå Could not parse invoice date for EXT SAP filtering: ${invoiceDate}`);
                }
            }
            
            const result = {
                internalCost: internalCost,
                externalCost: externalCost,
                totalCost: internalCost + externalCost
            };
            
            console.log(`üìä Final costs for ${getInvoiceNumber(invoice)}: Internal=${internalCost}, External=${externalCost}, Total=${result.totalCost}`);
            
            return result;
        }

        // ===== PROJECT SELECTION AND FILTERING FUNCTIONALITY =====
        
        let selectedProjectWBS = null;
        let selectedProjectName = null;
        let currentProjectFilter = null;

        function onProjectSelected(wbsCode, projectName) {
            selectedProjectWBS = wbsCode;
            selectedProjectName = projectName;
            
            // Enable the validate button
            const validateBtn = document.getElementById('validateProjectBtn');
            validateBtn.disabled = false;
            validateBtn.innerHTML = `üîç Validate invoices for ${projectName}`;
            
            console.log(`‚úÖ Project selected: ${projectName} (${wbsCode})`);
        }

        function validateSelectedProject() {
            if (!selectedProjectWBS || !selectedProjectName) {
                alert('Please select a project first.');
                return;
            }
            
            console.log(`üîç Validating invoices for project: ${selectedProjectName} (${selectedProjectWBS})`);
            
            // Set the project filter
            currentProjectFilter = {
                wbsCode: selectedProjectWBS,
                projectName: selectedProjectName
            };
            
            // Switch to Pending Invoices tab
            switchTab('pending');
            
            // Apply the project filter
            applyProjectFilterToPendingInvoices();
        }

        function applyProjectFilterToPendingInvoices() {
            if (!currentProjectFilter) return;
            
            // Show the filter bar
            const filterBar = document.getElementById('projectFilterBar');
            const projectNameSpan = document.getElementById('filteredProjectName');
            
            filterBar.style.display = 'block';
            projectNameSpan.textContent = `${currentProjectFilter.projectName} (${currentProjectFilter.wbsCode})`;
            
            // Filter the pending invoices table
            filterPendingInvoicesTable();
            
            console.log(`üéØ Applied project filter: ${currentProjectFilter.projectName}`);
        }

        function filterPendingInvoicesTable() {
            const tableBody = document.getElementById('pendingInvoicesTableBody');
            const rows = tableBody.querySelectorAll('tr');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const projectCell = row.cells[2]; // Project column (index 2)
                if (projectCell) {
                    const projectText = projectCell.textContent.trim();
                    const shouldShow = !currentProjectFilter || projectText.includes(currentProjectFilter.wbsCode);
                    
                    row.style.display = shouldShow ? '' : 'none';
                    if (shouldShow) visibleCount++;
                }
            });
            
            // Update filter bar if it exists
            const filterBar = document.getElementById('projectFilterBar');
            const filteredProjectName = document.getElementById('filteredProjectName');
            
            if (currentProjectFilter && filterBar && filteredProjectName) {
                filteredProjectName.textContent = currentProjectFilter.projectName;
                filterBar.style.display = 'block';
            }
            
            console.log(`üìä Filtered pending invoices: ${visibleCount} visible`);
        }

        function clearPendingProjectFilter() {
            currentProjectFilter = null;
            
            // Hide the filter bar
            const filterBar = document.getElementById('projectFilterBar');
            filterBar.style.display = 'none';
            
            // Show all rows
            const tableBody = document.getElementById('pendingInvoicesTableBody');
            const rows = tableBody.querySelectorAll('tr');
            
            rows.forEach(row => {
                row.style.display = '';
            });
            
            // Clear filter bar if it exists
            const filteredProjectName = document.getElementById('filteredProjectName');
            if (filteredProjectName) {
                filteredProjectName.textContent = '';
            }
            
            console.log('üóëÔ∏è Cleared project filter');
        }

        // Modify the existing filterProjects function to handle pending invoices filter
        async function filterProjects() {
            const projectFilter = document.getElementById('projectFilter').value.toLowerCase();
            const pendingInvoicesFilter = document.getElementById('pendingInvoicesFilter').checked;
            
            console.log(`üîç Filtering projects: name="${projectFilter}", pendingOnly=${pendingInvoicesFilter}`);
            
            // Get pending invoices to check which projects have pending invoices
            let projectsWithPendingInvoices = new Set();
            if (pendingInvoicesFilter) {
                const pendingInvoices = await getPendingInvoices();
                pendingInvoices.forEach(invoice => {
                    const invoiceData = invoice.fullInvoiceData && invoice.fullInvoiceData[0] ? invoice.fullInvoiceData[0] : {};
                    const projectId = invoiceData.projectId;
                    if (projectId) {
                        const wbsCode = standardizeWBS(projectId);
                        if (wbsCode) {
                            projectsWithPendingInvoices.add(wbsCode);
                        }
                    }
                });
                console.log(`üìã Projects with pending invoices:`, Array.from(projectsWithPendingInvoices));
            }
            
            // Filter the validation table rows
            const tableBody = document.getElementById('validationTableBody');
            const rows = tableBody.querySelectorAll('tr');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const wbsCell = row.cells[1]; // WBS Code column (index 1 now because of selection column)
                const projectCell = row.cells[2]; // Project Name column (index 2 now)
                
                if (wbsCell && projectCell) {
                    const wbsCode = wbsCell.textContent.trim();
                    const projectName = projectCell.textContent.toLowerCase();
                    
                    // Check name filter
                    const nameMatch = !projectFilter || projectName.includes(projectFilter);
                    
                    // Check pending invoices filter
                    const pendingMatch = !pendingInvoicesFilter || projectsWithPendingInvoices.has(wbsCode);
                    
                    const shouldShow = nameMatch && pendingMatch;
                    row.style.display = shouldShow ? '' : 'none';
                    
                    if (shouldShow) visibleCount++;
                }
            });
            
            // Update filter results
            const filterResults = document.getElementById('filterResults');
            if (projectFilter || pendingInvoicesFilter) {
                filterResults.style.display = 'block';
                let filterText = `Showing ${visibleCount} projects`;
                if (projectFilter) filterText += ` matching "${projectFilter}"`;
                if (pendingInvoicesFilter) filterText += ` with pending invoices`;
                filterResults.innerHTML = `<div style="color: #059669; font-weight: 500;">${filterText}</div>`;
            } else {
                filterResults.style.display = 'none';
            }
            
            console.log(`üìä Filtered projects: ${visibleCount} visible`);
        }


        // ===== COST TYPE EXPAND/COLLAPSE FUNCTIONALITY =====
        function toggleCostType(costType) {
            const content = document.querySelector(`.cost-type-${costType}`);
            const button = document.querySelector(`[onclick="toggleCostType('${costType}')"] .expand-btn`);
            
            if (!content || !button) {
                console.error(`Cost type section not found: ${costType}`);
                return;
            }
            
            const isExpanded = content.style.display !== 'none';
            
            if (isExpanded) {
                // Collapse
                content.style.display = 'none';
                button.textContent = '‚ñ∂';
            } else {
                // Expand
                content.style.display = 'block';
                button.textContent = '‚ñº';
            }
            
            console.log(`${isExpanded ? 'Collapsed' : 'Expanded'} ${costType} cost type section`);
        }

        // ===== COST VIEWS FUNCTIONALITY REMOVED =====
        // Cost Views functionality has been moved to I2E_Cost_view.html

        // All Cost Views functions have been removed and moved to I2E_Cost_view.html
        

        // Pivot table month expand/collapse functionality
        function togglePivotMonth(monthId) {
            const weekDetailsRows = document.querySelectorAll(`.week-details-${monthId}`);
            const toggleButton = document.getElementById(`toggle_${monthId}`);
            
            if (!toggleButton) return;
            
            const isExpanded = toggleButton.textContent === '‚ñº';
            
            if (isExpanded) {
                // Collapse - hide week details
                weekDetailsRows.forEach(row => row.style.display = 'none');
                toggleButton.textContent = '‚ñ∂';
            } else {
                // Expand - show week details
                weekDetailsRows.forEach(row => row.style.display = '');
                toggleButton.textContent = '‚ñº';
            }
            
            console.log(`${isExpanded ? 'Collapsed' : 'Expanded'} month: ${monthId}`);
        }
        
        // ===== DEBUG FUNCTIONS =====
        
        async function debugValidatorCacheData() {
            console.log('üîç Debug Validator Cache Data:');
            console.log('Raw localStorage data:');
            console.log('  - i2e_pending_invoices:', localStorage.getItem('i2e_pending_invoices'));
            console.log('  - i2e_approved_invoices:', localStorage.getItem('i2e_approved_invoices'));
            console.log('  - i2e_rejected_invoices:', localStorage.getItem('i2e_rejected_invoices'));
            
            console.log('Parsed cache data:');
            const pendingInvoices = await getPendingInvoices();
            const approvedInvoices = await getApprovedInvoices();
            const rejectedInvoices = await getRejectedInvoices();
            
            console.log('  - Pending invoices:', pendingInvoices);
            console.log('  - Approved invoices:', approvedInvoices);
            console.log('  - Rejected invoices:', rejectedInvoices);
            
            console.log('Cache stats:');
            try {
                const cacheStats = await getCacheStats();
                console.log('  - Cache stats:', cacheStats);
            } catch (error) {
                console.log('  - Cache stats error:', error);
            }
            
            console.log('Validation data object:');
            console.log('  - validationData:', validationData);
        }
        
        // Make debug function globally available
        window.debugValidatorCacheData = debugValidatorCacheData;
        
        // ===== CACHE EXPORT FUNCTION =====
        
        async function exportCacheData() {
            try {
                const exportData = await exportCacheToExcel();
                if (exportData.length === 0) {
                    alert('No cache data to export.');
                    return;
                }
                
                // Define basic field definitions for the export
                const basicFields = {
                    'invoiceNumber': { name: 'Invoice Number' },
                    'projectId': { name: 'Project ID' },
                    'customerId': { name: 'Customer ID' },
                    'dateOfInvoice': { name: 'Invoice Date' },
                    'monthOfInvoice': { name: 'Month of Invoice' },
                    'positionTotal': { name: 'Position Total' },
                    'approvalStatus': { name: 'Approval Status' },
                    'approvalDate': { name: 'Approval Date' },
                    'approvedBy': { name: 'Approved By' },
                    'comments': { name: 'Comments' }
                };
                
                // Get available fields from the export data
                const availableFields = exportData.length > 0 ? Object.keys(exportData[0]) : [];
                const fieldKeys = availableFields.filter(key => basicFields[key] || key === 'approvalStatus');
                
                // Use the enhanced export functionality with status sheet
                exportToExcelWithFields(exportData, fieldKeys, basicFields, 'I2E_Cache_Export');
                
                console.log(`‚úÖ Cache exported: ${exportData.length} line items`);
                
            } catch (error) {
                console.error('Error exporting cache:', error);
                alert('Error exporting cache data. Please try again.');
            }
        }
        
        // Make export function globally available
        window.exportCacheData = exportCacheData;
        
        // ===== NO PENDING INVOICES MODAL =====
        
        async function checkAndShowExportReminder() {
            const pendingInvoices = await getPendingInvoices();
            const approvedInvoices = await getApprovedInvoices();
            const rejectedInvoices = await getRejectedInvoices();
            
            // Show reminder if no pending invoices but have approved/rejected invoices
            if (pendingInvoices.length === 0 && (approvedInvoices.length > 0 || rejectedInvoices.length > 0)) {
                showExportReminderModal();
            }
        }
        
        function showExportReminderModal() {
            const modal = document.getElementById('exportReminderModal');
            if (modal) {
                modal.style.display = 'block';
            }
        }
        
        function closeExportReminderModal() {
            const modal = document.getElementById('exportReminderModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Export reminder is triggered after approval/rejection actions, not on page load

    </script>
    
    <!-- Export Reminder Modal -->
    <div id="exportReminderModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px; text-align: center;">
            <div class="modal-header">
                <h2 class="modal-title">üéâ All Invoices Validated!</h2>
            </div>
            <div style="padding: 2rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">‚úÖ</div>
                <p style="font-size: 1.1rem; margin-bottom: 2rem; line-height: 1.6;">
                    You have validated all invoices! Make sure to export your data to Excel to preserve your work.
                </p>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button class="btn btn-primary" onclick="exportCacheData(); closeExportReminderModal();" style="padding: 0.75rem 1.5rem;">
                        üì§ Export your data to Excel
                    </button>
                    <button class="btn" onclick="closeExportReminderModal()" style="padding: 0.75rem 1.5rem;">
                        OK
                    </button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>